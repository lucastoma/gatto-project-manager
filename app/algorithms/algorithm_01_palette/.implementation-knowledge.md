# Algorithm 01: Palette Mapping - Implementation Knowledge

## ALGORITHM THEORY

### Core Concept
**Palette Mapping** is a color matching technique that:
1. Extracts dominant colors from master image using K-means clustering
2. Maps each pixel in target image to closest color in extracted palette
3. Results in target image adopting master's color scheme

### Mathematical Foundation

#### K-means Clustering for Palette Extraction
```python
# RGB to LAB conversion for perceptual color distance
def rgb_to_lab(rgb):
    # sRGB to XYZ conversion
    # XYZ to LAB conversion with D65 illuminant
    
# Euclidean distance in LAB space
def color_distance(lab1, lab2):
    return sqrt((lab1[0]-lab2[0])² + (lab1[1]-lab2[1])² + (lab1[2]-lab2[2])²)
```

#### Performance Characteristics
- **Speed:** O(n*k*iterations) where n=pixels, k=colors, iterations=convergence
- **Memory:** O(n) for pixel data + O(k) for centroids
- **Quality:** Best for images with distinct color regions

## CURRENT IMPLEMENTATION ANALYSIS

### Existing Code Location
**File:** `app/processing/color_matching.py`
**Function:** `simple_palette_mapping(master_path, target_path, k=8)`

### Key Dependencies
- `sklearn.cluster.KMeans` - For palette extraction
- `cv2` (OpenCV) - For image I/O and processing
- `numpy` - For array operations
- `colorspacious` - For LAB color space conversion

### Parameter Analysis
- **k** (default=8): Number of colors in palette
  - Range: 4-32 (JSX constraint)
  - Sweet spot: 8-16 for most images
  - Impact: Lower k = more stylized, Higher k = more accurate

### Current Workflow
1. Load master image → RGB array
2. K-means clustering → k dominant colors
3. Load target image → RGB array  
4. For each target pixel → find closest master color
5. Replace target pixel → matched color
6. Save result → TIFF format

## INTEGRATION KNOWLEDGE

### API Integration
**Endpoint:** `POST /api/colormatch`
**Parameters:**
- `master_image`: multipart file
- `target_image`: multipart file
- `method`: "1" (for palette mapping)
- `k`: integer (4-32, default=8)

**Response Format:** `success,method1,{filename}`

### JSX Integration
**Script:** `app/scripts/color_matcher.jsx`
**Method:** Method 1 selection in dialog
**Files:** Exports as TIFF to `temp_jsx/`
**Output:** Imports result TIFF back to Photoshop

### Performance Monitoring
**Operation ID:** "color_matching_palette"
**Algorithm ID:** "algorithm_01_palette"
**Metrics:** Processing time, memory usage, image dimensions

## OPTIMIZATION OPPORTUNITIES

### Performance Improvements
1. **Image Downsampling:** Process smaller version for palette extraction
2. **Vectorized Operations:** Use numpy broadcasting for pixel mapping
3. **LAB Conversion Caching:** Pre-compute LAB values for common RGB colors
4. **Memory Management:** Process images in chunks for large files

### Quality Improvements
1. **Adaptive K Selection:** Auto-determine optimal k based on image complexity
2. **Perceptual Weighting:** Weight colors by visual importance/area
3. **Edge Preservation:** Protect high-contrast edges during mapping
4. **Color Space Options:** Support different color spaces (HSV, LUV)

### Integration Improvements
1. **Progress Callbacks:** Real-time progress for long operations
2. **Preview Generation:** Quick low-res preview before full processing
3. **Batch Processing:** Multiple target images with same master
4. **Undo Support:** Save original for reversible operations

## TESTING STRATEGY

### Unit Tests
- K-means convergence validation
- Color distance calculation accuracy
- Edge cases (k > unique colors, empty images)
- Memory usage within limits

### Integration Tests
- API endpoint response format
- File I/O with various formats
- JSX script compatibility
- Performance benchmarks

### Visual Tests
- Known good test cases
- Regression testing with reference images
- Human evaluation criteria
- Cross-platform consistency
