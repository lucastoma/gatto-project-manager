# project name: Gatto Nero Ai Manager (PY+JSX+WebView no md)

WORKSPACE ROOT: D:\Unity\Projects\GattoNeroPhotoshop

SCRIPT LOCATION: D:\Unity\Projects\GattoNeroPhotoshop\.doc-gen

---

## Spis Grup

1. **Kod główny** (0 plików)
   - Pliki Markdown z dokumentacją algorytmów
   - Wykluczenia: *test*, *__pycache__*, *.pyc, *legacy*, *temp*

2. **Webview** (5 plików)
   - Wszystkie pliki Python w workspace
   - Wykluczenia: *test*, *__pycache__*, *.pyc, *temp*

3. **Skrypty JSX** (5 plików)
   - Skrypty Adobe JSX dla Photoshop
   - Wykluczenia: *backup*, *old*

**Łącznie plików: 10**

---

## Grupa 1: Kod główny

*Pliki Markdown z dokumentacją algorytmów*

*Brak plików w tej grupie.*

---

## Grupa 2: Webview

*Wszystkie pliki Python w workspace*

### Lista plików (5)

- __init__.py (\app\webview)
- routes.py (\app\webview)
- main.css (\app\webview\static\css)
- main.js (\app\webview\static\js)
- __init__.py (\app\webview\utils)

### Zawartość plików

#### __init__.py - ./app/webview/__init__.py

``````
"""WebView Package

Web interface for testing and debugging algorithms before JSX integration.

This package provides:
- Web-based algorithm testing interface
- File upload and parameter configuration
- Live result preview and debugging
- Export functionality for results

Modules:
- routes: Flask routes and API endpoints
- utils: Helper functions and utilities
- tests: Test suite for WebView functionality

Usage:
    from app.webview import webview_bp
    app.register_blueprint(webview_bp)

Version: 1.0.0
Author: GattoNero Development Team
Status: Development - Phase 1 (Basic Functionality)
"""

from .routes import webview_bp

__version__ = '1.0.0'
__author__ = 'GattoNero Development Team'
__status__ = 'Development'

# Export the blueprint for easy import
__all__ = ['webview_bp']
``````

#### routes.py - ./app/webview/routes.py

``````
"""WebView Routes

Flask routes for the WebView interface.
Provides web-based testing and debugging for algorithms.
"""

import os
import json
from datetime import datetime
from flask import Blueprint, render_template, request, jsonify, current_app, send_file
from werkzeug.utils import secure_filename
from werkzeug.exceptions import RequestEntityTooLarge

# Import core services
try:
    from ..core.image_processor import ImageProcessor
    from ..algorithms.algorithm_01_palette.main import process_image as process_palette
    from ..api.utils import validate_image, create_response
except ImportError as e:
    print(f"Warning: Could not import core services: {e}")
    # Fallback imports or mock functions can be added here
    ImageProcessor = None
    process_palette = None

# Create Blueprint
webview_bp = Blueprint('webview', __name__, 
                      template_folder='templates',
                      static_folder='static',
                      url_prefix='/webview')

# Configuration
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}
UPLOAD_FOLDER = 'temp_uploads'

def allowed_file(filename):
    """Check if file extension is allowed."""
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def ensure_upload_folder():
    """Ensure upload folder exists."""
    if not os.path.exists(UPLOAD_FOLDER):
        os.makedirs(UPLOAD_FOLDER)

def log_activity(action, details=None, level='info'):
    """Log WebView activity."""
    timestamp = datetime.now().isoformat()
    log_entry = {
        'timestamp': timestamp,
        'action': action,
        'details': details or {},
        'level': level
    }
    
    # Log to Flask logger
    if hasattr(current_app, 'logger'):
        if level == 'error':
            current_app.logger.error(f"WebView: {action} - {details}")
        elif level == 'warning':
            current_app.logger.warning(f"WebView: {action} - {details}")
        else:
            current_app.logger.info(f"WebView: {action} - {details}")
    
    return log_entry

@webview_bp.route('/')
def index():
    """WebView main page."""
    log_activity('page_view', {'page': 'index'})
    return render_template('index.html')

@webview_bp.route('/algorithm_01')
def algorithm_01():
    """Algorithm 01 - Palette testing page."""
    log_activity('page_view', {'page': 'algorithm_01'})
    return render_template('algorithm_01.html')

@webview_bp.route('/api/health')
def health_check():
    """Health check endpoint for WebView."""
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.now().isoformat(),
        'webview_version': '1.0.0',
        'services': {
            'image_processor': ImageProcessor is not None,
            'algorithm_01': process_palette is not None
        }
    })

@webview_bp.route('/api/process', methods=['POST'])
def process_algorithm():
    """Process algorithm with uploaded image and parameters."""
    try:
        # Check if file is present
        if 'image_file' not in request.files:
            log_activity('process_error', {'error': 'No file uploaded'}, 'error')
            return jsonify({
                'success': False,
                'error': 'Nie wybrano pliku do przetworzenia'
            }), 400
        
        file = request.files['image_file']
        if file.filename == '':
            log_activity('process_error', {'error': 'Empty filename'}, 'error')
            return jsonify({
                'success': False,
                'error': 'Nie wybrano pliku do przetworzenia'
            }), 400
        
        # Validate file
        if not allowed_file(file.filename):
            log_activity('process_error', {'error': 'Invalid file type', 'filename': file.filename}, 'error')
            return jsonify({
                'success': False,
                'error': f'Nieprawidłowy typ pliku. Dozwolone: {", ".join(ALLOWED_EXTENSIONS)}'
            }), 400
        
        # Get algorithm type
        algorithm = request.form.get('algorithm', 'algorithm_01')
        
        # Get parameters
        params = {
            'num_colors': int(request.form.get('num_colors', 5)),
            'method': request.form.get('method', 'kmeans'),
            'quality': int(request.form.get('quality', 5)),
            'include_metadata': request.form.get('include_metadata') == 'on'
        }
        
        log_activity('process_start', {
            'algorithm': algorithm,
            'filename': file.filename,
            'params': params
        })
        
        # Ensure upload folder exists
        ensure_upload_folder()
        
        # Save uploaded file temporarily
        filename = secure_filename(file.filename)
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        temp_filename = f"{timestamp}_{filename}"
        temp_path = os.path.join(UPLOAD_FOLDER, temp_filename)
        file.save(temp_path)
        
        try:
            # Process based on algorithm type
            if algorithm == 'algorithm_01':
                result = process_algorithm_01(temp_path, params)
            else:
                raise ValueError(f"Nieznany algorytm: {algorithm}")
            
            log_activity('process_success', {
                'algorithm': algorithm,
                'filename': filename,
                'result_colors': len(result.get('palette', []))
            })
            
            return jsonify({
                'success': True,
                'result': result,
                'algorithm': algorithm,
                'timestamp': datetime.now().isoformat()
            })
            
        finally:
            # Clean up temporary file
            if os.path.exists(temp_path):
                os.remove(temp_path)
    
    except RequestEntityTooLarge:
        log_activity('process_error', {'error': 'File too large'}, 'error')
        return jsonify({
            'success': False,
            'error': f'Plik zbyt duży. Maksymalny rozmiar: {MAX_FILE_SIZE // (1024*1024)}MB'
        }), 413
    
    except ValueError as e:
        log_activity('process_error', {'error': str(e)}, 'error')
        return jsonify({
            'success': False,
            'error': str(e)
        }), 400
    
    except Exception as e:
        log_activity('process_error', {'error': str(e)}, 'error')
        current_app.logger.error(f"WebView processing error: {e}")
        return jsonify({
            'success': False,
            'error': 'Wystąpił błąd podczas przetwarzania obrazu'
        }), 500

def process_algorithm_01(image_path, params):
    """Process Algorithm 01 - Palette extraction."""
    try:
        # Check if algorithm is available
        if process_palette is None:
            # Fallback implementation for testing
            return create_mock_palette_result(params)
        
        # Call the actual algorithm
        result = process_palette(
            image_path=image_path,
            num_colors=params['num_colors'],
            method=params['method'],
            quality=params['quality']
        )
        
        # Add metadata if requested
        if params['include_metadata']:
            result['metadata'] = get_image_metadata(image_path)
        
        # Ensure result format consistency
        if 'palette' not in result and 'colors' in result:
            result['palette'] = result['colors']
        
        return result
        
    except Exception as e:
        current_app.logger.error(f"Algorithm 01 processing error: {e}")
        raise ValueError(f"Błąd przetwarzania algorytmu: {str(e)}")

def create_mock_palette_result(params):
    """Create mock result for testing when algorithm is not available."""
    import random
    
    # Generate mock colors
    colors = []
    for i in range(params['num_colors']):
        r = random.randint(0, 255)
        g = random.randint(0, 255)
        b = random.randint(0, 255)
        
        hex_color = f"#{r:02x}{g:02x}{b:02x}"
        
        colors.append({
            'hex': hex_color,
            'rgb': [r, g, b],
            'hsl': rgb_to_hsl(r, g, b),
            'percentage': random.uniform(5, 25)
        })
    
    return {
        'palette': colors,
        'algorithm': 'algorithm_01',
        'method': params['method'],
        'num_colors': params['num_colors'],
        'quality': params['quality'],
        'processing_time': random.uniform(0.5, 2.0),
        'mock': True  # Indicate this is mock data
    }

def rgb_to_hsl(r, g, b):
    """Convert RGB to HSL."""
    r, g, b = r/255.0, g/255.0, b/255.0
    max_val = max(r, g, b)
    min_val = min(r, g, b)
    h, s, l = 0, 0, (max_val + min_val) / 2
    
    if max_val == min_val:
        h = s = 0  # achromatic
    else:
        d = max_val - min_val
        s = d / (2 - max_val - min_val) if l > 0.5 else d / (max_val + min_val)
        if max_val == r:
            h = (g - b) / d + (6 if g < b else 0)
        elif max_val == g:
            h = (b - r) / d + 2
        elif max_val == b:
            h = (r - g) / d + 4
        h /= 6
    
    return [round(h * 360), round(s * 100), round(l * 100)]

def get_image_metadata(image_path):
    """Extract basic image metadata."""
    try:
        from PIL import Image
        
        with Image.open(image_path) as img:
            metadata = {
                'filename': os.path.basename(image_path),
                'format': img.format,
                'mode': img.mode,
                'size': img.size,
                'width': img.width,
                'height': img.height,
                'file_size': os.path.getsize(image_path)
            }
            
            # Add EXIF data if available
            if hasattr(img, '_getexif') and img._getexif():
                metadata['exif'] = dict(img._getexif())
            
            return metadata
            
    except Exception as e:
        current_app.logger.warning(f"Could not extract metadata: {e}")
        return {
            'filename': os.path.basename(image_path),
            'file_size': os.path.getsize(image_path),
            'error': 'Could not extract detailed metadata'
        }

@webview_bp.route('/api/algorithms')
def list_algorithms():
    """List available algorithms."""
    algorithms = [
        {
            'id': 'algorithm_01',
            'name': 'Palette Extraction',
            'description': 'Ekstrakcja palety kolorów z obrazu',
            'status': 'available' if process_palette else 'mock',
            'parameters': {
                'num_colors': {'type': 'int', 'min': 1, 'max': 20, 'default': 5},
                'method': {'type': 'select', 'options': ['kmeans', 'median_cut'], 'default': 'kmeans'},
                'quality': {'type': 'int', 'min': 1, 'max': 10, 'default': 5},
                'include_metadata': {'type': 'bool', 'default': True}
            }
        }
    ]
    
    return jsonify({
        'algorithms': algorithms,
        'count': len(algorithms)
    })

@webview_bp.route('/api/logs')
def get_logs():
    """Get recent WebView activity logs."""
    # This is a simplified implementation
    # In a real application, you might want to store logs in a database or file
    return jsonify({
        'logs': [
            {
                'timestamp': datetime.now().isoformat(),
                'level': 'info',
                'message': 'WebView system operational'
            }
        ]
    })

@webview_bp.errorhandler(413)
def too_large(e):
    """Handle file too large error."""
    log_activity('error', {'error': 'File too large'}, 'error')
    return jsonify({
        'success': False,
        'error': f'Plik zbyt duży. Maksymalny rozmiar: {MAX_FILE_SIZE // (1024*1024)}MB'
    }), 413

@webview_bp.errorhandler(404)
def not_found(e):
    """Handle 404 errors in WebView."""
    log_activity('error', {'error': '404 Not Found', 'path': request.path}, 'warning')
    return render_template('404.html'), 404

@webview_bp.errorhandler(500)
def internal_error(e):
    """Handle 500 errors in WebView."""
    log_activity('error', {'error': '500 Internal Server Error'}, 'error')
    return render_template('500.html'), 500

# Context processors for templates
@webview_bp.context_processor
def inject_webview_context():
    """Inject common context variables into templates."""
    return {
        'webview_version': '1.0.0',
        'current_time': datetime.now(),
        'max_file_size_mb': MAX_FILE_SIZE // (1024 * 1024),
        'allowed_extensions': list(ALLOWED_EXTENSIONS)
    }

# Template filters
@webview_bp.app_template_filter('filesize')
def filesize_filter(size_bytes):
    """Format file size in human readable format."""
    if size_bytes == 0:
        return "0 B"
    
    size_names = ["B", "KB", "MB", "GB"]
    i = 0
    while size_bytes >= 1024 and i < len(size_names) - 1:
        size_bytes /= 1024.0
        i += 1
    
    return f"{size_bytes:.1f} {size_names[i]}"

@webview_bp.app_template_filter('datetime')
def datetime_filter(dt, format='%Y-%m-%d %H:%M:%S'):
    """Format datetime object."""
    if isinstance(dt, str):
        try:
            dt = datetime.fromisoformat(dt.replace('Z', '+00:00'))
        except:
            return dt
    
    return dt.strftime(format)
``````

#### main.css - ./app/webview/static/css/main.css

``````
/* WebView Main Styles */
/* Główne style dla interfejsu WebView */

:root {
    /* Kolory zgodne z motywem GattoNero */
    --primary-color: #2c3e50;
    --secondary-color: #3498db;
    --success-color: #27ae60;
    --warning-color: #f39c12;
    --error-color: #e74c3c;
    --background-color: #ecf0f1;
    --text-color: #2c3e50;
    --border-color: #bdc3c7;
    --shadow-color: rgba(0, 0, 0, 0.1);
    
    /* Spacing */
    --spacing-xs: 0.25rem;
    --spacing-sm: 0.5rem;
    --spacing-md: 1rem;
    --spacing-lg: 1.5rem;
    --spacing-xl: 2rem;
    
    /* Border radius */
    --border-radius: 0.375rem;
    --border-radius-lg: 0.5rem;
}

/* Reset i podstawy */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    line-height: 1.6;
    color: var(--text-color);
    background-color: var(--background-color);
}

/* Layout główny */
.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: var(--spacing-md);
}

.header {
    background: white;
    border-bottom: 1px solid var(--border-color);
    padding: var(--spacing-md) 0;
    margin-bottom: var(--spacing-xl);
    box-shadow: 0 2px 4px var(--shadow-color);
}

.header h1 {
    color: var(--primary-color);
    font-size: 1.875rem;
    font-weight: 600;
}

.nav {
    margin-top: var(--spacing-md);
}

.nav a {
    color: var(--secondary-color);
    text-decoration: none;
    margin-right: var(--spacing-lg);
    font-weight: 500;
    transition: color 0.2s;
}

.nav a:hover {
    color: var(--primary-color);
}

.nav a.active {
    color: var(--primary-color);
    border-bottom: 2px solid var(--secondary-color);
    padding-bottom: var(--spacing-xs);
}

/* Karty i panele */
.card {
    background: white;
    border-radius: var(--border-radius-lg);
    padding: var(--spacing-lg);
    margin-bottom: var(--spacing-lg);
    box-shadow: 0 2px 8px var(--shadow-color);
    border: 1px solid var(--border-color);
}

.card-header {
    border-bottom: 1px solid var(--border-color);
    padding-bottom: var(--spacing-md);
    margin-bottom: var(--spacing-lg);
}

.card-title {
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--primary-color);
}

/* Formularze */
.form-group {
    margin-bottom: var(--spacing-lg);
}

.form-label {
    display: block;
    margin-bottom: var(--spacing-sm);
    font-weight: 500;
    color: var(--text-color);
}

.form-input {
    width: 100%;
    padding: var(--spacing-sm) var(--spacing-md);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    font-size: 1rem;
    transition: border-color 0.2s, box-shadow 0.2s;
}

.form-input:focus {
    outline: none;
    border-color: var(--secondary-color);
    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
}

.form-select {
    width: 100%;
    padding: var(--spacing-sm) var(--spacing-md);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    background-color: white;
    font-size: 1rem;
}

/* Przyciski */
.btn {
    display: inline-block;
    padding: var(--spacing-sm) var(--spacing-lg);
    border: none;
    border-radius: var(--border-radius);
    font-size: 1rem;
    font-weight: 500;
    text-decoration: none;
    cursor: pointer;
    transition: all 0.2s;
    text-align: center;
}

.btn-primary {
    background-color: var(--secondary-color);
    color: white;
}

.btn-primary:hover {
    background-color: #2980b9;
    transform: translateY(-1px);
    box-shadow: 0 4px 8px var(--shadow-color);
}

.btn-success {
    background-color: var(--success-color);
    color: white;
}

.btn-success:hover {
    background-color: #229954;
}

.btn-warning {
    background-color: var(--warning-color);
    color: white;
}

.btn-warning:hover {
    background-color: #e67e22;
}

.btn-danger {
    background-color: var(--error-color);
    color: white;
}

.btn-danger:hover {
    background-color: #c0392b;
}

.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
}

/* Grid layout */
.grid {
    display: grid;
    gap: var(--spacing-lg);
}

.grid-2 {
    grid-template-columns: 1fr 1fr;
}

.grid-3 {
    grid-template-columns: 1fr 1fr 1fr;
}

@media (max-width: 768px) {
    .grid-2,
    .grid-3 {
        grid-template-columns: 1fr;
    }
}

/* Upload area */
.upload-area {
    border: 2px dashed var(--border-color);
    border-radius: var(--border-radius-lg);
    padding: var(--spacing-xl);
    text-align: center;
    transition: border-color 0.2s, background-color 0.2s;
    cursor: pointer;
}

.upload-area:hover {
    border-color: var(--secondary-color);
    background-color: rgba(52, 152, 219, 0.05);
}

.upload-area.dragover {
    border-color: var(--secondary-color);
    background-color: rgba(52, 152, 219, 0.1);
}

/* Image preview */
.image-preview {
    max-width: 100%;
    max-height: 300px;
    border-radius: var(--border-radius);
    box-shadow: 0 2px 8px var(--shadow-color);
}

.image-container {
    text-align: center;
    margin: var(--spacing-lg) 0;
}

/* Status i alerty */
.alert {
    padding: var(--spacing-md);
    border-radius: var(--border-radius);
    margin-bottom: var(--spacing-lg);
    border-left: 4px solid;
}

.alert-info {
    background-color: #d6eaf8;
    border-color: var(--secondary-color);
    color: #1b4f72;
}

.alert-success {
    background-color: #d5f4e6;
    border-color: var(--success-color);
    color: #0e4b2a;
}

.alert-warning {
    background-color: #fdeaa7;
    border-color: var(--warning-color);
    color: #7d4f00;
}

.alert-error {
    background-color: #fadbd8;
    border-color: var(--error-color);
    color: #641e16;
}

/* Loading spinner */
.spinner {
    border: 3px solid #f3f3f3;
    border-top: 3px solid var(--secondary-color);
    border-radius: 50%;
    width: 30px;
    height: 30px;
    animation: spin 1s linear infinite;
    margin: var(--spacing-md) auto;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Progress bar */
.progress {
    width: 100%;
    height: 8px;
    background-color: #f3f3f3;
    border-radius: var(--border-radius);
    overflow: hidden;
    margin: var(--spacing-md) 0;
}

.progress-bar {
    height: 100%;
    background-color: var(--secondary-color);
    transition: width 0.3s ease;
}

/* Log panel */
.log-panel {
    background-color: #1e1e1e;
    color: #f8f8f2;
    padding: var(--spacing-md);
    border-radius: var(--border-radius);
    font-family: 'Courier New', monospace;
    font-size: 0.875rem;
    max-height: 300px;
    overflow-y: auto;
    white-space: pre-wrap;
}

.log-entry {
    margin-bottom: var(--spacing-xs);
}

.log-debug { color: #6c757d; }
.log-info { color: #17a2b8; }
.log-warning { color: #ffc107; }
.log-error { color: #dc3545; }

/* Utilities */
.text-center { text-align: center; }
.text-left { text-align: left; }
.text-right { text-align: right; }

.mt-0 { margin-top: 0; }
.mt-1 { margin-top: var(--spacing-sm); }
.mt-2 { margin-top: var(--spacing-md); }
.mt-3 { margin-top: var(--spacing-lg); }

.mb-0 { margin-bottom: 0; }
.mb-1 { margin-bottom: var(--spacing-sm); }
.mb-2 { margin-bottom: var(--spacing-md); }
.mb-3 { margin-bottom: var(--spacing-lg); }

.hidden { display: none; }
.visible { display: block; }

/* Responsive */
@media (max-width: 768px) {
    .container {
        padding: var(--spacing-sm);
    }
    
    .header h1 {
        font-size: 1.5rem;
    }
    
    .nav a {
        display: block;
        margin-bottom: var(--spacing-sm);
        margin-right: 0;
    }
    
    .card {
        padding: var(--spacing-md);
    }
}
``````

#### main.js - ./app/webview/static/js/main.js

``````
/**
 * WebView Main JavaScript
 * Główne funkcje dla interfejsu WebView
 */

// Globalne zmienne
window.WebView = {
    config: {
        maxFileSize: 10 * 1024 * 1024, // 10MB
        allowedTypes: ['image/jpeg', 'image/png', 'image/jpg'],
        apiBaseUrl: '/api',
        webviewBaseUrl: '/webview'
    },
    state: {
        currentTask: null,
        uploadedFiles: {},
        lastResults: null
    }
};

// Utility Functions
class WebViewUtils {
    /**
     * Wyświetl komunikat użytkownikowi
     */
    static showMessage(message, type = 'info') {
        const alertDiv = document.createElement('div');
        alertDiv.className = `alert alert-${type}`;
        alertDiv.textContent = message;
        
        // Znajdź kontener na komunikaty lub wstaw na początku main
        const container = document.querySelector('.container');
        container.insertBefore(alertDiv, container.firstChild);
        
        // Usuń komunikat po 5 sekundach
        setTimeout(() => {
            if (alertDiv.parentNode) {
                alertDiv.parentNode.removeChild(alertDiv);
            }
        }, 5000);
    }
    
    /**
     * Walidacja pliku przed uploadem
     */
    static validateFile(file) {
        const errors = [];
        
        // Sprawdź typ pliku
        if (!WebView.config.allowedTypes.includes(file.type)) {
            errors.push(`Nieprawidłowy typ pliku. Dozwolone: ${WebView.config.allowedTypes.join(', ')}`);
        }
        
        // Sprawdź rozmiar
        if (file.size > WebView.config.maxFileSize) {
            const maxSizeMB = WebView.config.maxFileSize / (1024 * 1024);
            errors.push(`Plik zbyt duży. Maksymalny rozmiar: ${maxSizeMB}MB`);
        }
        
        return errors;
    }
    
    /**
     * Konwertuj plik do base64 dla podglądu
     */
    static fileToBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }
    
    /**
     * Formatuj rozmiar pliku
     */
    static formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    /**
     * Debounce function
     */
    static debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
}

// File Upload Handler
class FileUploadHandler {
    constructor(dropZone, fileInput, previewContainer) {
        this.dropZone = dropZone;
        this.fileInput = fileInput;
        this.previewContainer = previewContainer;
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        // Drag and drop events
        this.dropZone.addEventListener('dragover', this.handleDragOver.bind(this));
        this.dropZone.addEventListener('dragleave', this.handleDragLeave.bind(this));
        this.dropZone.addEventListener('drop', this.handleDrop.bind(this));
        
        // Click to upload
        this.dropZone.addEventListener('click', () => {
            this.fileInput.click();
        });
        
        // File input change
        this.fileInput.addEventListener('change', this.handleFileSelect.bind(this));
    }
    
    handleDragOver(e) {
        e.preventDefault();
        this.dropZone.classList.add('dragover');
    }
    
    handleDragLeave(e) {
        e.preventDefault();
        this.dropZone.classList.remove('dragover');
    }
    
    handleDrop(e) {
        e.preventDefault();
        this.dropZone.classList.remove('dragover');
        
        const files = Array.from(e.dataTransfer.files);
        this.processFiles(files);
    }
    
    handleFileSelect(e) {
        const files = Array.from(e.target.files);
        this.processFiles(files);
    }
    
    async processFiles(files) {
        for (const file of files) {
            const errors = WebViewUtils.validateFile(file);
            
            if (errors.length > 0) {
                WebViewUtils.showMessage(errors.join(', '), 'error');
                continue;
            }
            
            try {
                await this.displayPreview(file);
                WebViewUtils.showMessage(`Plik ${file.name} został załadowany`, 'success');
            } catch (error) {
                WebViewUtils.showMessage(`Błąd podczas ładowania pliku: ${error.message}`, 'error');
            }
        }
    }
    
    async displayPreview(file) {
        const base64 = await WebViewUtils.fileToBase64(file);
        
        const previewHtml = `
            <div class="image-container">
                <img src="${base64}" alt="${file.name}" class="image-preview">
                <p><strong>${file.name}</strong> (${WebViewUtils.formatFileSize(file.size)})</p>
            </div>
        `;
        
        this.previewContainer.innerHTML = previewHtml;
        
        // Zapisz plik w stanie globalnym
        const fieldName = this.fileInput.name;
        WebView.state.uploadedFiles[fieldName] = file;
    }
}

// Parameter Manager
class ParameterManager {
    constructor(formElement) {
        this.form = formElement;
        this.setupValidation();
    }
    
    setupValidation() {
        // Walidacja w czasie rzeczywistym
        const inputs = this.form.querySelectorAll('input, select, textarea');
        inputs.forEach(input => {
            input.addEventListener('input', WebViewUtils.debounce(() => {
                this.validateField(input);
            }, 300));
        });
    }
    
    validateField(field) {
        const value = field.value;
        const fieldName = field.name;
        let isValid = true;
        let errorMessage = '';
        
        // Walidacja specyficzna dla typu pola
        switch (field.type) {
            case 'number':
                const min = parseFloat(field.min);
                const max = parseFloat(field.max);
                const numValue = parseFloat(value);
                
                if (isNaN(numValue)) {
                    isValid = false;
                    errorMessage = 'Wartość musi być liczbą';
                } else if (min !== undefined && numValue < min) {
                    isValid = false;
                    errorMessage = `Wartość musi być >= ${min}`;
                } else if (max !== undefined && numValue > max) {
                    isValid = false;
                    errorMessage = `Wartość musi być <= ${max}`;
                }
                break;
                
            case 'text':
                if (field.required && !value.trim()) {
                    isValid = false;
                    errorMessage = 'To pole jest wymagane';
                }
                break;
        }
        
        // Wyświetl błąd walidacji
        this.displayFieldError(field, isValid ? null : errorMessage);
        
        return isValid;
    }
    
    displayFieldError(field, errorMessage) {
        // Usuń poprzedni błąd
        const existingError = field.parentNode.querySelector('.field-error');
        if (existingError) {
            existingError.remove();
        }
        
        // Dodaj nowy błąd jeśli istnieje
        if (errorMessage) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'field-error';
            errorDiv.style.color = 'var(--error-color)';
            errorDiv.style.fontSize = '0.875rem';
            errorDiv.style.marginTop = '0.25rem';
            errorDiv.textContent = errorMessage;
            
            field.parentNode.appendChild(errorDiv);
            field.style.borderColor = 'var(--error-color)';
        } else {
            field.style.borderColor = 'var(--border-color)';
        }
    }
    
    validateForm() {
        const inputs = this.form.querySelectorAll('input, select, textarea');
        let isValid = true;
        
        inputs.forEach(input => {
            if (!this.validateField(input)) {
                isValid = false;
            }
        });
        
        return isValid;
    }
    
    getFormData() {
        const formData = new FormData(this.form);
        const data = {};
        
        for (let [key, value] of formData.entries()) {
            data[key] = value;
        }
        
        return data;
    }
}

// API Client
class APIClient {
    static async request(endpoint, options = {}) {
        const url = `${WebView.config.apiBaseUrl}${endpoint}`;
        
        const defaultOptions = {
            headers: {
                'Content-Type': 'application/json'
            }
        };
        
        const finalOptions = { ...defaultOptions, ...options };
        
        try {
            const response = await fetch(url, finalOptions);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const contentType = response.headers.get('content-type');
            if (contentType && contentType.includes('application/json')) {
                return await response.json();
            } else {
                return await response.text();
            }
        } catch (error) {
            console.error('API Request failed:', error);
            throw error;
        }
    }
    
    static async processAlgorithm(algorithmId, files, parameters) {
        const formData = new FormData();
        
        // Dodaj pliki
        for (const [key, file] of Object.entries(files)) {
            formData.append(key, file);
        }
        
        // Dodaj parametry
        for (const [key, value] of Object.entries(parameters)) {
            formData.append(key, value);
        }
        
        return await this.request(`/process`, {
            method: 'POST',
            headers: {}, // Usuń Content-Type dla FormData
            body: formData
        });
    }
    
    static async getTaskStatus(taskId) {
        return await this.request(`/task/${taskId}`);
    }
}

// Task Monitor
class TaskMonitor {
    constructor(taskId, onUpdate, onComplete, onError) {
        this.taskId = taskId;
        this.onUpdate = onUpdate;
        this.onComplete = onComplete;
        this.onError = onError;
        this.interval = null;
        this.start();
    }
    
    start() {
        this.interval = setInterval(async () => {
            try {
                const status = await APIClient.getTaskStatus(this.taskId);
                
                if (status.status === 'completed') {
                    this.stop();
                    this.onComplete(status.result);
                } else if (status.status === 'failed') {
                    this.stop();
                    this.onError(status.error);
                } else {
                    this.onUpdate(status);
                }
            } catch (error) {
                this.stop();
                this.onError(error.message);
            }
        }, 1000); // Sprawdzaj co sekundę
    }
    
    stop() {
        if (this.interval) {
            clearInterval(this.interval);
            this.interval = null;
        }
    }
}

// Progress Bar
class ProgressBar {
    constructor(element) {
        this.element = element;
        this.bar = element.querySelector('.progress-bar');
    }
    
    setProgress(percentage) {
        this.bar.style.width = `${Math.max(0, Math.min(100, percentage))}%`;
    }
    
    show() {
        this.element.classList.remove('hidden');
    }
    
    hide() {
        this.element.classList.add('hidden');
    }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    console.log('WebView JavaScript initialized');
    
    // Initialize file upload handlers
    const uploadZones = document.querySelectorAll('.upload-area');
    uploadZones.forEach(zone => {
        const fileInput = zone.querySelector('input[type="file"]') || 
                         zone.parentNode.querySelector('input[type="file"]');
        const previewContainer = zone.parentNode.querySelector('.preview-container');
        
        if (fileInput && previewContainer) {
            new FileUploadHandler(zone, fileInput, previewContainer);
        }
    });
    
    // Initialize parameter forms
    const parameterForms = document.querySelectorAll('.parameter-form');
    parameterForms.forEach(form => {
        new ParameterManager(form);
    });
});

// Export for global access
window.WebViewUtils = WebViewUtils;
window.FileUploadHandler = FileUploadHandler;
window.ParameterManager = ParameterManager;
window.APIClient = APIClient;
window.TaskMonitor = TaskMonitor;
window.ProgressBar = ProgressBar;
``````

#### __init__.py - ./app/webview/utils/__init__.py

``````
"""WebView Utils Package - Narzędzia pomocnicze dla WebView.

Moduły:
    image_processor: Przetwarzanie obrazów dla interfejsu webowego
    parameter_validator: Walidacja parametrów algorytmów
    result_formatter: Formatowanie wyników dla wyświetlenia
    algorithm_detector: Wykrywanie dostępnych algorytmów
"""

__version__ = '1.0.0'
``````

---

## Grupa 3: Skrypty JSX

*Skrypty Adobe JSX dla Photoshop*

### Lista plików (5)

- color_matcher_v1.2.jsx (\app\scripts)
- color_matcher_v1.4.jsx (\app\scripts)
- color_matcher_v1.6.jsx (\app\scripts)
- palette_analyzer.jsx (\app\scripts)
- test_simple.jsx (\app\scripts)

### Zawartość plików

#### color_matcher_v1.2.jsx - ./app/scripts/color_matcher_v1.2.jsx

``````
// GattoNero Color Matcher - v1.2 with Advanced Logging - DO NOT EDIT THIS, it is working v1.2 version, finalized.

#target photoshop

// << ZMIANA: Prosta i niezawodna funkcja do logowania na pulpicie.
function writeToLog(message) {
    try {
        var logFile = new File(Folder.desktop + "/gatto_nero_log.txt");
        logFile.open("a"); // "a" oznacza dopisywanie do pliku (append)
        logFile.encoding = "UTF-8";
        logFile.writeln(new Date().toTimeString().substr(0, 8) + ": " + message);
        logFile.close();
    } catch (e) {
        // Ignoruj błędy zapisu do logu, aby nie przerywać głównego skryptu
    }
}

// << ZMIANA: Rozpoczynamy logowanie od razu.
writeToLog("--- Script execution started ---");


// --- KONFIGURACJA ---
var SERVER_URL = "http://127.0.0.1:5000/api/colormatch";

// --- GŁÓWNA FUNKCJA ---
function main() {
    if (app.documents.length < 2) {
        alert("Otwórz co najmniej dwa dokumenty (master i target), aby uruchomić skrypt.");
        writeToLog("Error: Less than 2 documents open. Script terminated.");
        return;
    }

    writeToLog("Showing configuration dialog.");
    var config = showConfigurationDialog();
    if (config === null) {
        writeToLog("User cancelled the dialog. Script terminated.");
        return; // Użytkownik anulował
    }
    writeToLog("Configuration received: Method " + config.method + ", Preview: " + config.is_preview);

    var tempFolder = new Folder(config.projectRoot + "/temp_jsx");
    if (!tempFolder.exists) {
        tempFolder.create();
        writeToLog("Created temp folder: " + tempFolder.fsName);
    }

    var masterFile = null;
    var targetFile = null;

    try {
        alert("Rozpoczynam przetwarzanie... Sprawdź plik gatto_nero_log.txt na pulpicie, aby śledzić postęp.");

        writeToLog("Saving master document: " + config.masterDoc.name);
        masterFile = saveDocumentToTIFF(config.masterDoc, tempFolder, "master");
        writeToLog("Master file saved to: " + masterFile.fsName);

        writeToLog("Saving target document: " + config.targetDoc.name);
        targetFile = saveDocumentToTIFF(config.targetDoc, tempFolder, "target");
        writeToLog("Target file saved to: " + targetFile.fsName);

        writeToLog("Executing server request (curl).");
        var response = executeCurl(masterFile, targetFile, config);
        writeToLog("Raw server response: " + response);

        writeToLog("Parsing server response.");
        var result = parseColorMatchResponse(response);
        writeToLog("Parsed response successfully. Filename: " + result.filename);

        writeToLog("Opening result file.");
        openResultFile(result.filename, config.projectRoot, config.is_preview);

    } catch (e) {
        writeToLog("!!! SCRIPT CRASHED !!! Error: " + e.message);
        alert("Wystąpił krytyczny błąd: \n" + e.message + "\n\nSprawdź plik gatto_nero_log.txt na pulpicie po więcej szczegółów.");
    } finally {
        writeToLog("Cleaning up temporary files.");
        cleanupFile(masterFile);
        cleanupFile(targetFile);
        writeToLog("--- Script execution finished ---");
    }
}

function executeCurl(masterFile, targetFile, config) {
    var url = config.is_preview ? "http://127.0.0.1:5000/api/colormatch/preview" : SERVER_URL;

    // << ZMIANA: Używamy PEŁNEJ ŚCIEŻKI do curl i usuwamy flagę -s (silent), aby był bardziej "gadatliwy"
    var curlExecutable = "C:/Windows/System32/curl.exe";

    var command = '"' + curlExecutable + '" -s -X POST ' + // << DODANO -s (silent)
        '-F "master_image=@' + masterFile.fsName + '" ' +
        '-F "target_image=@' + targetFile.fsName + '" ' +
        '-F "method=' + config.method + '" ' +
        '-F "k=' + config.k + '" ' +
        '-F "distance_metric=' + config.distanceMetric + '" ' +
        '-F "use_dithering=' + config.useDithering + '" ' +
        '-F "preserve_luminance=' + config.preserveLuminance + '" ' +
        url;

    writeToLog("Executing command: " + command);

    var result = "";
    var tempFolder = masterFile.parent;

    if ($.os.indexOf("Windows") > -1) {
        var cmdFile = new File(tempFolder + "/colormatch_curl.cmd");
        var stdoutFile = new File(tempFolder + "/curl_stdout.txt");
        var stderrFile = new File(tempFolder + "/curl_stderr.txt");
        try {
            cmdFile.open("w");
            cmdFile.encoding = "UTF-8";
            cmdFile.writeln("@echo off");
            cmdFile.writeln(command);
            cmdFile.close();

            if (stdoutFile.exists) stdoutFile.remove();
            if (stderrFile.exists) stderrFile.remove();

            app.system('cmd /c ""' + cmdFile.fsName + '" 1> "' + stdoutFile.fsName + '" 2> "' + stderrFile.fsName + '""');

            var maxWaitTime = 15000;
            var waitInterval = 500;
            var totalWait = 0;
            while (totalWait < maxWaitTime && (!stdoutFile.exists || stdoutFile.length === 0) && (!stderrFile.exists || stderrFile.length === 0)) {
                $.sleep(waitInterval);
                totalWait += waitInterval;
            }

            var errorOutput = "";
            if (stderrFile.exists && stderrFile.length > 0) {
                stderrFile.open("r");
                errorOutput = stderrFile.read();
                stderrFile.close();
                writeToLog("CURL stderr: " + errorOutput); // << ZMIANA: Logujemy błąd
            }

            var stdOutput = "";
            if (stdoutFile.exists && stdoutFile.length > 0) {
                stdoutFile.open("r");
                stdOutput = stdoutFile.read();
                stdoutFile.close();
                writeToLog("CURL stdout: " + stdOutput); // << ZMIANA: Logujemy wyjście
            }

            if (errorOutput) {
                throw new Error("Błąd wykonania CURL (szczegóły w logu): " + errorOutput);
            }

            result = stdOutput;

        } finally {
            cleanupFile(cmdFile);
            cleanupFile(stdoutFile);
            cleanupFile(stderrFile);
        }
    } else { // macOS
        result = app.doScript('do shell script "' + command + '"', Language.APPLESCRIPT);
    }

    if (result.replace(/^\s+|\s+$/g, "") === "") {
        throw new Error("Nie otrzymano odpowiedzi od serwera (stdout był pusty).");
    }
    return result;
}

// --- Pozostałe funkcje (bez istotnych zmian) ---
// (showConfigurationDialog, saveDocumentToTIFF, openResultFile, cleanupFile)
function showConfigurationDialog() {
    var docList = [];
    for (var i = 0; i < app.documents.length; i++) {
        docList.push(app.documents[i].name);
    }

    var dialog = new Window("dialog", "GattoNero Color Matcher");
    dialog.orientation = "column";
    dialog.alignChildren = ["fill", "top"];

    // --- Panel Master ---
    var masterPanel = dialog.add("panel", undefined, "1. Wybierz obraz WZORCOWY (Master)");
    masterPanel.alignChildren = "left";
    masterPanel.add("statictext", undefined, "Dokument:");
    var masterDropdown = masterPanel.add("dropdownlist", undefined, docList);
    masterDropdown.selection = 0;

    // --- Panel Target ---
    var targetPanel = dialog.add("panel", undefined, "2. Wybierz obraz DOCELOWY (Target)");
    targetPanel.alignChildren = "left";
    targetPanel.add("statictext", undefined, "Dokument:");
    var targetDropdown = targetPanel.add("dropdownlist", undefined, docList);
    targetDropdown.selection = (docList.length > 1) ? 1 : 0;

    // --- Panel Metody ---
    var methodPanel = dialog.add("panel", undefined, "3. Wybierz metodę i parametry");
    methodPanel.alignChildren = "left";
    methodPanel.add("statictext", undefined, "Metoda dopasowania:");
    var methodDropdown = methodPanel.add("dropdownlist", undefined, [
        "1: Palette Mapping",
        "2: Statistical Transfer",
        "3: Histogram Matching"
    ]);
    methodDropdown.selection = 0;

    var kGroup = methodPanel.add("group");
    kGroup.add("statictext", undefined, "Liczba kolorów w palecie (dla Metody 1):");
    var kInput = kGroup.add("edittext", undefined, "16"); // Default to 16
    kInput.characters = 3;

    // --- Panel Opcji Zaawansowanych ---
    var advancedOptionsPanel = dialog.add("panel", undefined, "4. Opcje Zaawansowane");
    advancedOptionsPanel.alignChildren = "left";

    advancedOptionsPanel.add("statictext", undefined, "Metryka odległości:");
    var distanceMetricDropdown = advancedOptionsPanel.add("dropdownlist", undefined, [
        "weighted_rgb: Percepcyjna (domyślna)",
        "rgb: Szybka (RGB)",
        "lab: Percepcyjna (LAB)"
    ]);
    distanceMetricDropdown.selection = 0; // Default to weighted_rgb

    var ditheringCheckbox = advancedOptionsPanel.add("checkbox", undefined, "Włącz rozpraszanie (Dithering)");
    ditheringCheckbox.value = false;

    var preserveLuminanceCheckbox = advancedOptionsPanel.add("checkbox", undefined, "Zachowaj jasność oryginału");
    preserveLuminanceCheckbox.value = false;

    // --- Przyciski ---
    var buttonGroup = dialog.add("group");
    buttonGroup.orientation = "row";
    buttonGroup.alignChildren = ["fill", "center"];
    buttonGroup.add("button", undefined, "Anuluj", {
        name: "cancel"
    });
    var previewButton = buttonGroup.add("button", undefined, "Generuj Podgląd", {
        name: "preview"
    });
    var runButton = buttonGroup.add("button", undefined, "Uruchom", {
        name: "ok"
    });

    previewButton.onClick = function() {
        var kValue = parseInt(kInput.text);
        if (isNaN(kValue) || kValue < 4 || kValue > 64) { // Updated range for K
            alert("Liczba kolorów musi być w zakresie 4-64.");
            return;
        }
        if (masterDropdown.selection.index === targetDropdown.selection.index) {
            alert("Dokument Master i Target muszą być różne.");
            return;
        }
        result = {
            masterDoc: app.documents[masterDropdown.selection.index],
            targetDoc: app.documents[targetDropdown.selection.index],
            method: methodDropdown.selection.text.split(":")[0],
            k: kValue,
            distanceMetric: distanceMetricDropdown.selection.text.split(":")[0],
            useDithering: ditheringCheckbox.value,
            preserveLuminance: preserveLuminanceCheckbox.value,
            projectRoot: new File($.fileName).parent.parent,
            is_preview: true
        };
        dialog.close();
    };

    runButton.onClick = function() {
        var kValue = parseInt(kInput.text);
        if (isNaN(kValue) || kValue < 4 || kValue > 64) { // Updated range for K
            alert("Liczba kolorów musi być w zakresie 4-64.");
            return;
        }
        if (masterDropdown.selection.index === targetDropdown.selection.index) {
            alert("Dokument Master i Target muszą być różne.");
            return;
        }
        result = {
            masterDoc: app.documents[masterDropdown.selection.index],
            targetDoc: app.documents[targetDropdown.selection.index],
            method: methodDropdown.selection.text.split(":")[0],
            k: kValue,
            distanceMetric: distanceMetricDropdown.selection.text.split(":")[0],
            useDithering: ditheringCheckbox.value,
            preserveLuminance: preserveLuminanceCheckbox.value,
            projectRoot: new File($.fileName).parent.parent.parent,
            is_preview: false
        };
        dialog.close();
    };

    dialog.show();
    return result;
}

function saveDocumentToTIFF(doc, folderPath, prefix) {
    var activeDoc = app.activeDocument;
    app.activeDocument = doc;

    var filePath = new File(folderPath + "/" + prefix + "_" + Date.now() + ".tif");
    var tiffOptions = new TiffSaveOptions();
    tiffOptions.imageCompression = TIFFEncoding.NONE;
    tiffOptions.layers = false;

    doc.saveAs(filePath, tiffOptions, true, Extension.LOWERCASE);

    app.activeDocument = activeDoc;
    return filePath;
}

function parseColorMatchResponse(response) {
    try {
        // Najpierw usuwamy wszystkie możliwe znaki nowej linii z całego tekstu
        var cleaned_response = response.replace(/(\r\n|\n|\r)/gm, "");

        // Następnie usuwamy białe znaki z początku i końca
        cleaned_response = cleaned_response.replace(/^\s+|\s+$/g, "");

        var parts = cleaned_response.split(",");

        if (parts.length < 1) throw new Error("Pusta odpowiedź serwera");

        var status = parts[0];
        if (status === "error") {
            throw new Error("Błąd serwera: " + (parts.length > 1 ? parts.slice(1).join(',') : "Nieznany błąd"));
        }
        if (status !== "success" || parts.length < 3) {
            throw new Error("Nieprawidłowa odpowiedź serwera (oczekiwano 'success,method,filename'): " + cleaned_response);
        }

        // Zwracamy obiekt z idealnie czystą nazwą pliku
        return {
            status: status,
            method: parts[1],
            filename: parts[2]
        };

    } catch (e) {
        throw new Error("Błąd parsowania odpowiedzi: " + e.message + "\nOryginalna odpowiedź: " + response);
    }
}

function openResultFile(filename, projectRoot, is_preview) {
    var resultsFolder = new Folder(projectRoot + "/results");
    var resultFile = new File(resultsFolder.fsName + "/" + filename);

    // --- PANCERNA PĘTLA OCZEKIWANIA NA PLIK ---
    var max_wait_ms = 20000; // Maksymalny czas oczekiwania: 20 sekund
    var interval_ms = 500; // Sprawdzaj co pół sekundy
    var elapsed_ms = 0;
    var fileFound = false;

    writeToLog("Waiting for result file: " + resultFile.fsName);

    while (elapsed_ms < max_wait_ms) {
        if (resultFile.exists) {
            fileFound = true;
            writeToLog("File found after " + elapsed_ms + "ms.");
            break; // Znaleziono plik, wyjdź z pętli
        }

        $.sleep(interval_ms); // Czekaj
        elapsed_ms += interval_ms;
    }

    if (!fileFound) {
        throw new Error("Plik wynikowy nie istnieje (nawet po " + (max_wait_ms / 1000) + " sekundach oczekiwania): " + resultFile.fsName);
    }
    // --- KONIEC PĘTLI OCZEKIWANIA ---

    // Otwórz plik, gdy już na pewno istnieje
    if (is_preview) {
        var resultDoc = app.open(resultFile);
        resultDoc.name = "ColorMatch_Preview_" + filename;
        alert("Podgląd wygenerowany! Plik otwarty:\n" + filename + "\n\nZamknij podgląd, aby kontynuować.");
    } else {
        var resultDoc = app.open(resultFile);
        resultDoc.name = "ColorMatch_" + filename;
        alert("Gotowe! Color Matching zakończony.\n\nWynik został otwarty w nowym dokumencie.");
    }
}

function cleanupFile(file) {
    if (file && file.exists) {
        try {
            file.remove();
        } catch (e) {
            /* ignoruj błędy */ }
    }
}

// --- URUCHOMIENIE ---
main();
``````

#### color_matcher_v1.4.jsx - ./app/scripts/color_matcher_v1.4.jsx

``````
// GattoNero Color Matcher - v1.5 (Final Build with Surgical Logging)
#target photoshop

function writeToLog(message) {
    try {
        var logFile = new File(Folder.desktop + "/gatto_nero_log.txt");
        logFile.open("a");
        logFile.encoding = "UTF-8";
        logFile.writeln(new Date().toTimeString().substr(0, 8) + ": " + message);
        logFile.close();
    } catch (e) {}
}

writeToLog("--- Script execution started (v1.5) ---");

var SERVER_URL = "http://127.0.0.1:5000/api/colormatch";

function main() {
    if (app.documents.length < 2) {
        alert("Otwórz co najmniej dwa dokumenty (master i target), aby uruchomić skrypt.");
        writeToLog("Error: Less than 2 documents open. Script terminated.");
        return;
    }
    
    writeToLog("Showing configuration dialog.");
    var config = showConfigurationDialog();

    if (config === null) {
        writeToLog("User cancelled the dialog or a critical error occured inside dialog function. Script terminated.");
        return;
    }
    
    writeToLog("Configuration received successfully. Starting process...");
    // Usunięto logowanie całego obiektu config, by nie zaśmiecać, mamy to w logach DEBUG
    
    var tempFolder = new Folder(config.projectRoot + "/temp_jsx");
    if (!tempFolder.exists) {
        tempFolder.create();
        writeToLog("Created temp folder: " + tempFolder.fsName);
    }

    var masterFile = null;
    var targetFile = null;
    
    try {
        alert("Rozpoczynam przetwarzanie... Sprawdź plik gatto_nero_log.txt na pulpicie, aby śledzić postęp.");
        
        masterFile = saveDocumentToTIFF(config.masterDoc, tempFolder, "master");
        targetFile = saveDocumentToTIFF(config.targetDoc, tempFolder, "target");

        var response = executeCurl(masterFile, targetFile, config);
        writeToLog("Raw server response: " + response);
        
        var result = parseColorMatchResponse(response);
        writeToLog("Parsed response successfully. Filename: " + result.filename);
        
        openResultFile(result.filename, config.projectRoot);
        
    } catch (e) {
        writeToLog("!!! SCRIPT CRASHED !!! Error: " + e.message + " (Line: " + e.line + ")");
        alert("Wystąpił krytyczny błąd: \n" + e.message + "\n\nSprawdź plik gatto_nero_log.txt na pulpicie po więcej szczegółów.");
    } finally {
        writeToLog("Cleaning up temporary files.");
        cleanupFile(masterFile);
        cleanupFile(targetFile);
        writeToLog("--- Script execution finished ---");
    }
}

function showConfigurationDialog() {
    var docList = [];
    for (var i = 0; i < app.documents.length; i++) {
        docList.push(app.documents[i].name);
    }

    var dialog = new Window("dialog", "GattoNero Color Matcher v1.5");
    dialog.orientation = "column";
    dialog.alignChildren = ["fill", "top"];

    var masterPanel = dialog.add("panel", undefined, "1. Obraz WZORCOWY (Master)");
    masterPanel.alignChildren = "left";
    masterPanel.add("statictext", undefined, "Dokument:");
    var masterDropdown = masterPanel.add("dropdownlist", undefined, docList);
    masterDropdown.selection = 0;

    var targetPanel = dialog.add("panel", undefined, "2. Obraz DOCELOWY (Target)");
    targetPanel.alignChildren = "left";
    targetPanel.add("statictext", undefined, "Dokument:");
    var targetDropdown = targetPanel.add("dropdownlist", undefined, docList);
    targetDropdown.selection = (docList.length > 1) ? 1 : 0;

    var methodPanel = dialog.add("panel", undefined, "3. Metoda i Główne Parametry");
    methodPanel.alignChildren = "left";
    methodPanel.add("statictext", undefined, "Metoda dopasowania:");
    var methodDropdown = methodPanel.add("dropdownlist", undefined, ["1: Palette Mapping", "2: Statistical Transfer", "3: Histogram Matching"]);
    methodDropdown.selection = 0;

    var kGroup = methodPanel.add("group");
    kGroup.add("statictext", undefined, "Liczba kolorów w palecie (dla Metody 1):");
    var kInput = kGroup.add("edittext", undefined, "16");
    kInput.characters = 3;
    
    var advancedOptionsPanel = dialog.add("panel", undefined, "4. Opcje Zaawansowane (dla Palette Mapping)");
    advancedOptionsPanel.orientation = "column";
    advancedOptionsPanel.alignChildren = "left";
    
    var ditheringGroup = advancedOptionsPanel.add('group');
    ditheringGroup.add("statictext", undefined, "Wygładzanie krawędzi:");
    var ditheringDropdown = ditheringGroup.add("dropdownlist", undefined, ["none: Szybko, ostre krawędzie", "floyd_steinberg: Wolniej, gładkie przejścia"]);
    ditheringDropdown.selection = 0;
    
    advancedOptionsPanel.add('statictext', undefined, 'Ochrona tonów skrajnych:');
    var injectExtremesCheckbox = advancedOptionsPanel.add("checkbox", undefined, "Dodaj czysty czarny/biały do palety");
    injectExtremesCheckbox.value = false;
    
    var preserveGroup = advancedOptionsPanel.add('group');
    var preserveExtremesCheckbox = preserveGroup.add("checkbox", undefined, "Chroń cienie i światła w obrazie docelowym");
    preserveExtremesCheckbox.value = false;

    var thresholdGroup = advancedOptionsPanel.add('group');
    thresholdGroup.add("statictext", undefined, "Próg ochrony (0-255):");
    var thresholdInput = thresholdGroup.add("edittext", undefined, "10");
    thresholdInput.characters = 3;
    thresholdInput.enabled = false;

    preserveExtremesCheckbox.onClick = function() {
        thresholdInput.enabled = this.value;
    };
    
    var buttonGroup = dialog.add("group");
    buttonGroup.orientation = "row";
    buttonGroup.alignChildren = ["fill", "center"];
    var runButton = buttonGroup.add("button", undefined, "Uruchom", { name: "ok" });
    var cancelButton = buttonGroup.add("button", undefined, "Anuluj", { name: "cancel" });
    
    var result = null;

    runButton.onClick = function() {
        // === POCZĄTEK LOGOWANIA CHIRURGICZNEGO ===
        try {
            writeToLog("DEBUG: 'Uruchom' clicked. Starting validation.");

            if (masterDropdown.selection.index === targetDropdown.selection.index) {
                alert("Dokument Master i Target muszą być różne.");
                writeToLog("DEBUG: Validation FAILED. Master and Target are the same.");
                return;
            }

            var kValue = parseInt(kInput.text);
            if (isNaN(kValue) || kValue < 4 || kValue > 64) {
                alert("Liczba kolorów musi być w zakresie 4-64.");
                writeToLog("DEBUG: Validation FAILED. Invalid k value: " + kInput.text);
                return;
            }
            writeToLog("DEBUG: kValue is OK: " + kValue);

            var thresholdValue = 0; 
            if (preserveExtremesCheckbox.value) {
                writeToLog("DEBUG: Preserve extremes is checked. Reading threshold value.");
                thresholdValue = parseInt(thresholdInput.text);
                if (isNaN(thresholdValue) || thresholdValue < 0 || thresholdValue > 255) {
                    alert("Gdy opcja ochrony jest włączona, jej próg musi być w zakresie 0-255.");
                    writeToLog("DEBUG: Validation FAILED. Invalid threshold value: " + thresholdInput.text);
                    return;
                }
                writeToLog("DEBUG: thresholdValue is OK: " + thresholdValue);
            } else {
                writeToLog("DEBUG: Preserve extremes is NOT checked.");
            }
            
            writeToLog("DEBUG: All validation passed. Creating result object.");

            result = {
                masterDoc: app.documents[masterDropdown.selection.index],
                targetDoc: app.documents[targetDropdown.selection.index],
                method: methodDropdown.selection.text.split(":")[0],
                k: kValue,
                ditheringMethod: (ditheringDropdown.selection.text.split(":")[0]).replace(/^[\s\u00A0]+|[\s\u00A0]+$/g, ''),
                injectExtremes: injectExtremesCheckbox.value,
                preserveExtremes: preserveExtremesCheckbox.value,
                extremesThreshold: thresholdValue,
                projectRoot: new File($.fileName).parent.parent.parent,
                is_preview: false // Ta opcja nie jest już używana w UI, ale może być w przyszłości
            };
            
            writeToLog("DEBUG: Result object created successfully. Closing dialog.");
            dialog.close();

        } catch (e) {
            var errorMessage = "KRYTYCZNY BŁĄD w przycisku 'Uruchom': " + e.message + " (linia: " + e.line + ")";
            writeToLog("!!! " + errorMessage);
            alert(errorMessage);
            // Nie zamykamy okna, ale błąd jest zalogowany
        }
        // === KONIEC LOGOWANIA CHIRURGICZNEGO ===
    };

    cancelButton.onClick = function() {
        writeToLog("DEBUG: 'Anuluj' button clicked.");
        result = null;
        dialog.close();
    };

    dialog.show();
    writeToLog("DEBUG: Dialog closed. Returning result. Is it null? " + (result === null));
    return result;
}

function executeCurl(masterFile, targetFile, config) {
    var url = SERVER_URL;
    var curlExecutable = "C:/Windows/System32/curl.exe";
    
    var command = '"' + curlExecutable + '" -s -X POST ' +
                  '-F "master_image=@' + masterFile.fsName + '" ' +
                  '-F "target_image=@' + targetFile.fsName + '" ' +
                  '-F "method=' + config.method + '" ' +
                  '-F "k=' + config.k + '" ' +
                  '-F "dithering_method=' + config.ditheringMethod + '" ' +
                  '-F "inject_extremes=' + config.injectExtremes + '" ' +
                  '-F "preserve_extremes=' + config.preserveExtremes + '" ' +
                  '-F "extremes_threshold=' + config.extremesThreshold + '" ' +
                  url;

    writeToLog("Executing command: " + command);

    var result = "";
    var tempFolder = masterFile.parent;

    if ($.os.indexOf("Windows") > -1) {
        var cmdFile = new File(tempFolder + "/colormatch_curl.cmd");
        var stdoutFile = new File(tempFolder + "/curl_stdout.txt");
        var stderrFile = new File(tempFolder + "/curl_stderr.txt");
        try {
            cmdFile.open("w");
            cmdFile.encoding = "UTF-8";
            cmdFile.writeln("@echo off");
            cmdFile.writeln(command);
            cmdFile.close();

            if (stdoutFile.exists) stdoutFile.remove();
            if (stderrFile.exists) stderrFile.remove();
            
            app.system('cmd /c ""' + cmdFile.fsName + '" 1> "' + stdoutFile.fsName + '" 2> "' + stderrFile.fsName + '""');
            
            var maxWaitTime = 30000;
            var waitInterval = 500;
            var totalWait = 0;
            while (totalWait < maxWaitTime && (!stdoutFile.exists || stdoutFile.length === 0) && (!stderrFile.exists || stderrFile.length > 0)) {
                $.sleep(waitInterval);
                totalWait += waitInterval;
            }

            var errorOutput = "";
            if (stderrFile.exists && stderrFile.length > 0) {
                stderrFile.open("r"); errorOutput = stderrFile.read(); stderrFile.close();
                writeToLog("CURL stderr: " + errorOutput);
            }

            var stdOutput = "";
            if (stdoutFile.exists && stdoutFile.length > 0) {
                stdoutFile.open("r"); stdOutput = stdoutFile.read(); stdoutFile.close();
                writeToLog("CURL stdout: " + stdOutput);
            }
            
            if (errorOutput) { throw new Error("Błąd wykonania CURL: " + errorOutput); }
            if (!stdOutput) { throw new Error("Nie otrzymano odpowiedzi od serwera (pusty stdout)."); }
            
            result = stdOutput;
        } finally {
            cleanupFile(cmdFile); cleanupFile(stdoutFile); cleanupFile(stderrFile);
        }
    } else {
        result = app.doScript('do shell script "' + command + '"', Language.APPLESCRIPT);
    }
    return result;
}

function parseColorMatchResponse(response) {
    try {
        var cleaned_response = response.replace(/(\r\n|\n|\r)/gm, "").replace(/^\s+|\s+$/g, "");
        var parts = cleaned_response.split(",");
        if (parts.length < 3 || parts[0] !== "success") {
             throw new Error("Nieprawidłowa odpowiedź serwera: " + cleaned_response);
        }
        return { status: parts[0], method: parts[1], filename: parts[2] };
    } catch (e) {
        throw new Error("Błąd parsowania odpowiedzi: " + e.message + ". Oryginalna odpowiedź: " + response);
    }
}

function openResultFile(filename, projectRoot) {
    var resultsFolder = new Folder(projectRoot + "/results");
    var resultFile = new File(resultsFolder.fsName + "/" + filename);
    
    var max_wait_ms = 20000;
    var interval_ms = 500;
    var elapsed_ms = 0;
    writeToLog("Waiting for result file: " + resultFile.fsName);

    while (elapsed_ms < max_wait_ms) {
        if (resultFile.exists) {
            writeToLog("File found after " + elapsed_ms + "ms.");
            var resultDoc = app.open(resultFile);
            resultDoc.name = "ColorMatch_" + filename;
            alert("Gotowe! Color Matching zakończony.\n\nWynik został otwarty w nowym dokumencie.");
            return;
        }
        $.sleep(interval_ms);
        elapsed_ms += interval_ms;
    }
    throw new Error("Plik wynikowy nie istnieje (nawet po " + (max_wait_ms / 1000) + "s): " + resultFile.fsName);
}

function saveDocumentToTIFF(doc, folderPath, prefix) {
    writeToLog("Saving document '" + doc.name + "' to TIFF...");
    var activeDoc = app.activeDocument;
    app.activeDocument = doc;
    var filePath = new File(folderPath + "/" + prefix + "_" + Date.now() + ".tif");
    var tiffOptions = new TiffSaveOptions();
    tiffOptions.imageCompression = TIFFEncoding.NONE;
    tiffOptions.layers = false;
    doc.saveAs(filePath, tiffOptions, true, Extension.LOWERCASE);
    app.activeDocument = activeDoc;
    writeToLog("Saved successfully to: " + filePath.fsName);
    return filePath;
}

function cleanupFile(file) {
    if (file && file.exists) {
        try { 
            file.remove();
            writeToLog("Cleaned up temp file: " + file.fsName);
        } catch (e) {}
    }
}

main();
``````

#### color_matcher_v1.6.jsx - ./app/scripts/color_matcher_v1.6.jsx

``````
// GattoNero Color Matcher - v1.6
#target photoshop

function writeToLog(message) {
    try {
        var logFile = new File(Folder.desktop + "/gatto_nero_log.txt");
        logFile.open("a");
        logFile.encoding = "UTF-8";
        logFile.writeln(new Date().toTimeString().substr(0, 8) + ": " + message);
        logFile.close();
    } catch (e) {}
}

writeToLog("--- Script execution started (v1.5) ---");

var SERVER_URL = "http://127.0.0.1:5000/api/colormatch";

function main() {
    if (app.documents.length < 2) {
        alert("Otwórz co najmniej dwa dokumenty (master i target), aby uruchomić skrypt.");
        writeToLog("Error: Less than 2 documents open. Script terminated.");
        return;
    }
    
    writeToLog("Showing configuration dialog.");
    var config = showConfigurationDialog();

    if (config === null) {
        writeToLog("User cancelled the dialog or a critical error occured inside dialog function. Script terminated.");
        return;
    }
    
    writeToLog("Configuration received successfully. Starting process...");
    // Usunięto logowanie całego obiektu config, by nie zaśmiecać, mamy to w logach DEBUG
    
    var tempFolder = new Folder(config.projectRoot + "/temp_jsx");
    if (!tempFolder.exists) {
        tempFolder.create();
        writeToLog("Created temp folder: " + tempFolder.fsName);
    }

    var masterFile = null;
    var targetFile = null;
    
    try {
        alert("Rozpoczynam przetwarzanie... Sprawdź plik gatto_nero_log.txt na pulpicie, aby śledzić postęp.");
        
        masterFile = saveDocumentToTIFF(config.masterDoc, tempFolder, "master");
        targetFile = saveDocumentToTIFF(config.targetDoc, tempFolder, "target");

        var response = executeCurl(masterFile, targetFile, config);
        writeToLog("Raw server response: " + response);
        
        var result = parseColorMatchResponse(response);
        writeToLog("Parsed response successfully. Filename: " + result.filename);
        
        openResultFile(result.filename, config.projectRoot);
        
    } catch (e) {
        writeToLog("!!! SCRIPT CRASHED !!! Error: " + e.message + " (Line: " + e.line + ")");
        alert("Wystąpił krytyczny błąd: \n" + e.message + "\n\nSprawdź plik gatto_nero_log.txt na pulpicie po więcej szczegółów.");
    } finally {
        writeToLog("Cleaning up temporary files.");
        cleanupFile(masterFile);
        cleanupFile(targetFile);
        writeToLog("--- Script execution finished ---");
    }
}

function showConfigurationDialog() {
    var docList = [];
    for (var i = 0; i < app.documents.length; i++) {
        docList.push(app.documents[i].name);
    }

    var dialog = new Window("dialog", "GattoNero Color Matcher v1.5");
    dialog.orientation = "column";
    dialog.alignChildren = ["fill", "top"];

    var masterPanel = dialog.add("panel", undefined, "1. Obraz WZORCOWY (Master)");
    masterPanel.alignChildren = "left";
    masterPanel.add("statictext", undefined, "Dokument:");
    var masterDropdown = masterPanel.add("dropdownlist", undefined, docList);
    masterDropdown.selection = 0;

    var targetPanel = dialog.add("panel", undefined, "2. Obraz DOCELOWY (Target)");
    targetPanel.alignChildren = "left";
    targetPanel.add("statictext", undefined, "Dokument:");
    var targetDropdown = targetPanel.add("dropdownlist", undefined, docList);
    targetDropdown.selection = (docList.length > 1) ? 1 : 0;

    var methodPanel = dialog.add("panel", undefined, "3. Metoda i Główne Parametry");
    methodPanel.alignChildren = "left";
    methodPanel.add("statictext", undefined, "Metoda dopasowania:");
    var methodDropdown = methodPanel.add("dropdownlist", undefined, ["1: Palette Mapping", "2: Statistical Transfer", "3: Histogram Matching"]);
    methodDropdown.selection = 0;

    var kGroup = methodPanel.add("group");
    kGroup.add("statictext", undefined, "Liczba kolorów w palecie (dla Metody 1):");
    var kInput = kGroup.add("edittext", undefined, "16");
    kInput.characters = 3;
    
    var advancedOptionsPanel = dialog.add("panel", undefined, "4. Opcje Zaawansowane (dla Palette Mapping)");
    advancedOptionsPanel.orientation = "column";
    advancedOptionsPanel.alignChildren = "left";
    
    var ditheringGroup = advancedOptionsPanel.add('group');
    ditheringGroup.add("statictext", undefined, "Wygładzanie krawędzi:");
    var ditheringDropdown = ditheringGroup.add("dropdownlist", undefined, ["none: Szybko, ostre krawędzie", "floyd_steinberg: Wolniej, gładkie przejścia"]);
    ditheringDropdown.selection = 0;
    
    advancedOptionsPanel.add('statictext', undefined, 'Ochrona tonów skrajnych:');
    var injectExtremesCheckbox = advancedOptionsPanel.add("checkbox", undefined, "Dodaj czysty czarny/biały do palety");
    injectExtremesCheckbox.value = false;
    
    var preserveGroup = advancedOptionsPanel.add('group');
    var preserveExtremesCheckbox = preserveGroup.add("checkbox", undefined, "Chroń cienie i światła w obrazie docelowym");
    preserveExtremesCheckbox.value = false;

    var thresholdGroup = advancedOptionsPanel.add('group');
    thresholdGroup.add("statictext", undefined, "Próg ochrony (0-255):");
    var thresholdInput = thresholdGroup.add("edittext", undefined, "10");
    thresholdInput.characters = 3;
    thresholdInput.enabled = false;

    preserveExtremesCheckbox.onClick = function() {
        thresholdInput.enabled = this.value;
    };
    
    // === NOWE PARAMETRY EDGE BLENDING ===
    var edgeBlendingPanel = dialog.add("panel", undefined, "5. Wygładzanie Krawędzi (Edge Blending)");
    edgeBlendingPanel.orientation = "column";
    edgeBlendingPanel.alignChildren = "left";
    
    var enableEdgeBlendingCheckbox = edgeBlendingPanel.add("checkbox", undefined, "Włącz wygładzanie krawędzi");
    enableEdgeBlendingCheckbox.value = false;
    
    var edgeDetectionGroup = edgeBlendingPanel.add('group');
    edgeDetectionGroup.add("statictext", undefined, "Próg detekcji krawędzi (0-100):");
    var edgeDetectionThresholdInput = edgeDetectionGroup.add("edittext", undefined, "25");
    edgeDetectionThresholdInput.characters = 3;
    edgeDetectionThresholdInput.enabled = false;
    
    var blurRadiusGroup = edgeBlendingPanel.add('group');
    blurRadiusGroup.add("statictext", undefined, "Promień rozmycia (0.5-5.0):");
    var edgeBlurRadiusInput = blurRadiusGroup.add("edittext", undefined, "1.0");
    edgeBlurRadiusInput.characters = 4;
    edgeBlurRadiusInput.enabled = false;
    
    var blurStrengthGroup = edgeBlendingPanel.add('group');
    blurStrengthGroup.add("statictext", undefined, "Siła rozmycia (0.0-1.0):");
    var edgeBlurStrengthInput = blurStrengthGroup.add("edittext", undefined, "0.5");
    edgeBlurStrengthInput.characters = 4;
    edgeBlurStrengthInput.enabled = false;
    
    enableEdgeBlendingCheckbox.onClick = function() {
        edgeDetectionThresholdInput.enabled = this.value;
        edgeBlurRadiusInput.enabled = this.value;
        edgeBlurStrengthInput.enabled = this.value;
    };
    
    var buttonGroup = dialog.add("group");
    buttonGroup.orientation = "row";
    buttonGroup.alignChildren = ["fill", "center"];
    var runButton = buttonGroup.add("button", undefined, "Uruchom", { name: "ok" });
    var cancelButton = buttonGroup.add("button", undefined, "Anuluj", { name: "cancel" });
    
    var result = null;

    runButton.onClick = function() {
        // === POCZĄTEK LOGOWANIA CHIRURGICZNEGO ===
        try {
            writeToLog("DEBUG: 'Uruchom' clicked. Starting validation.");

            if (masterDropdown.selection.index === targetDropdown.selection.index) {
                alert("Dokument Master i Target muszą być różne.");
                writeToLog("DEBUG: Validation FAILED. Master and Target are the same.");
                return;
            }

            var kValue = parseInt(kInput.text);
            if (isNaN(kValue) || kValue < 4 || kValue > 64) {
                alert("Liczba kolorów musi być w zakresie 4-64.");
                writeToLog("DEBUG: Validation FAILED. Invalid k value: " + kInput.text);
                return;
            }
            writeToLog("DEBUG: kValue is OK: " + kValue);

            var thresholdValue = 0; 
            if (preserveExtremesCheckbox.value) {
                writeToLog("DEBUG: Preserve extremes is checked. Reading threshold value.");
                thresholdValue = parseInt(thresholdInput.text);
                if (isNaN(thresholdValue) || thresholdValue < 0 || thresholdValue > 255) {
                    alert("Gdy opcja ochrony jest włączona, jej próg musi być w zakresie 0-255.");
                    writeToLog("DEBUG: Validation FAILED. Invalid threshold value: " + thresholdInput.text);
                    return;
                }
                writeToLog("DEBUG: thresholdValue is OK: " + thresholdValue);
            } else {
                writeToLog("DEBUG: Preserve extremes is NOT checked.");
            }
            
            // === WALIDACJA PARAMETRÓW EDGE BLENDING ===
            var edgeBlendingEnabled = enableEdgeBlendingCheckbox.value;
            var edgeDetectionThreshold = 25;
            var edgeBlurRadius = 1.0;
            var edgeBlurStrength = 0.5;
            
            if (edgeBlendingEnabled) {
                writeToLog("DEBUG: Edge blending is enabled. Validating parameters.");
                
                edgeDetectionThreshold = parseFloat(edgeDetectionThresholdInput.text);
                if (isNaN(edgeDetectionThreshold) || edgeDetectionThreshold < 0 || edgeDetectionThreshold > 100) {
                    alert("Próg detekcji krawędzi musi być w zakresie 0-100.");
                    writeToLog("DEBUG: Validation FAILED. Invalid edge detection threshold: " + edgeDetectionThresholdInput.text);
                    return;
                }
                
                edgeBlurRadius = parseFloat(edgeBlurRadiusInput.text);
                if (isNaN(edgeBlurRadius) || edgeBlurRadius < 0.5 || edgeBlurRadius > 5.0) {
                    alert("Promień rozmycia musi być w zakresie 0.5-5.0.");
                    writeToLog("DEBUG: Validation FAILED. Invalid edge blur radius: " + edgeBlurRadiusInput.text);
                    return;
                }
                
                edgeBlurStrength = parseFloat(edgeBlurStrengthInput.text);
                if (isNaN(edgeBlurStrength) || edgeBlurStrength < 0.0 || edgeBlurStrength > 1.0) {
                    alert("Siła rozmycia musi być w zakresie 0.0-1.0.");
                    writeToLog("DEBUG: Validation FAILED. Invalid edge blur strength: " + edgeBlurStrengthInput.text);
                    return;
                }
                
                writeToLog("DEBUG: Edge blending parameters validated successfully.");
            } else {
                writeToLog("DEBUG: Edge blending is NOT enabled.");
            }
            
            writeToLog("DEBUG: All validation passed. Creating result object.");

            result = {
                masterDoc: app.documents[masterDropdown.selection.index],
                targetDoc: app.documents[targetDropdown.selection.index],
                method: methodDropdown.selection.text.split(":")[0],
                k: kValue,
                ditheringMethod: (ditheringDropdown.selection.text.split(":")[0]).replace(/^[\s\u00A0]+|[\s\u00A0]+$/g, ''),
                injectExtremes: injectExtremesCheckbox.value,
                preserveExtremes: preserveExtremesCheckbox.value,
                extremesThreshold: thresholdValue,
                // === NOWE PARAMETRY EDGE BLENDING ===
                enableEdgeBlending: edgeBlendingEnabled,
                edgeDetectionThreshold: edgeDetectionThreshold,
                edgeBlurRadius: edgeBlurRadius,
                edgeBlurStrength: edgeBlurStrength,
                projectRoot: new File($.fileName).parent.parent.parent,
                is_preview: false // Ta opcja nie jest już używana w UI, ale może być w przyszłości
            };
            
            writeToLog("DEBUG: Result object created successfully. Closing dialog.");
            dialog.close();

        } catch (e) {
            var errorMessage = "KRYTYCZNY BŁĄD w przycisku 'Uruchom': " + e.message + " (linia: " + e.line + ")";
            writeToLog("!!! " + errorMessage);
            alert(errorMessage);
            // Nie zamykamy okna, ale błąd jest zalogowany
        }
        // === KONIEC LOGOWANIA CHIRURGICZNEGO ===
    };

    cancelButton.onClick = function() {
        writeToLog("DEBUG: 'Anuluj' button clicked.");
        result = null;
        dialog.close();
    };

    dialog.show();
    writeToLog("DEBUG: Dialog closed. Returning result. Is it null? " + (result === null));
    return result;
}

function executeCurl(masterFile, targetFile, config) {
    var url = SERVER_URL;
    var curlExecutable = "C:/Windows/System32/curl.exe";
    
    var command = '"' + curlExecutable + '" -s -X POST ' +
                  '-F "master_image=@' + masterFile.fsName + '" ' +
                  '-F "target_image=@' + targetFile.fsName + '" ' +
                  '-F "method=' + config.method + '" ' +
                  '-F "k=' + config.k + '" ' +
                  '-F "dithering_method=' + config.ditheringMethod + '" ' +
                  '-F "inject_extremes=' + config.injectExtremes + '" ' +
                  '-F "preserve_extremes=' + config.preserveExtremes + '" ' +
                  '-F "extremes_threshold=' + config.extremesThreshold + '" ' +
                  '-F "enable_edge_blending=' + config.enableEdgeBlending + '" ' +
                  '-F "edge_detection_threshold=' + config.edgeDetectionThreshold + '" ' +
                  '-F "edge_blur_radius=' + config.edgeBlurRadius + '" ' +
                  '-F "edge_blur_strength=' + config.edgeBlurStrength + '" ' +
                  url;

    writeToLog("Executing command: " + command);

    var result = "";
    var tempFolder = masterFile.parent;

    if ($.os.indexOf("Windows") > -1) {
        var cmdFile = new File(tempFolder + "/colormatch_curl.cmd");
        var stdoutFile = new File(tempFolder + "/curl_stdout.txt");
        var stderrFile = new File(tempFolder + "/curl_stderr.txt");
        try {
            cmdFile.open("w");
            cmdFile.encoding = "UTF-8";
            cmdFile.writeln("@echo off");
            cmdFile.writeln(command);
            cmdFile.close();

            if (stdoutFile.exists) stdoutFile.remove();
            if (stderrFile.exists) stderrFile.remove();
            
            app.system('cmd /c ""' + cmdFile.fsName + '" 1> "' + stdoutFile.fsName + '" 2> "' + stderrFile.fsName + '""');
            
            var maxWaitTime = 30000;
            var waitInterval = 500;
            var totalWait = 0;
            while (totalWait < maxWaitTime && (!stdoutFile.exists || stdoutFile.length === 0) && (!stderrFile.exists || stderrFile.length > 0)) {
                $.sleep(waitInterval);
                totalWait += waitInterval;
            }

            var errorOutput = "";
            if (stderrFile.exists && stderrFile.length > 0) {
                stderrFile.open("r"); errorOutput = stderrFile.read(); stderrFile.close();
                writeToLog("CURL stderr: " + errorOutput);
            }

            var stdOutput = "";
            if (stdoutFile.exists && stdoutFile.length > 0) {
                stdoutFile.open("r"); stdOutput = stdoutFile.read(); stdoutFile.close();
                writeToLog("CURL stdout: " + stdOutput);
            }
            
            if (errorOutput) { throw new Error("Błąd wykonania CURL: " + errorOutput); }
            if (!stdOutput) { throw new Error("Nie otrzymano odpowiedzi od serwera (pusty stdout)."); }
            
            result = stdOutput;
        } finally {
            cleanupFile(cmdFile); cleanupFile(stdoutFile); cleanupFile(stderrFile);
        }
    } else {
        result = app.doScript('do shell script "' + command + '"', Language.APPLESCRIPT);
    }
    return result;
}

function parseColorMatchResponse(response) {
    try {
        var cleaned_response = response.replace(/(\r\n|\n|\r)/gm, "").replace(/^\s+|\s+$/g, "");
        var parts = cleaned_response.split(",");
        if (parts.length < 3 || parts[0] !== "success") {
             throw new Error("Nieprawidłowa odpowiedź serwera: " + cleaned_response);
        }
        return { status: parts[0], method: parts[1], filename: parts[2] };
    } catch (e) {
        throw new Error("Błąd parsowania odpowiedzi: " + e.message + ". Oryginalna odpowiedź: " + response);
    }
}

function openResultFile(filename, projectRoot) {
    var resultsFolder = new Folder(projectRoot + "/results");
    var resultFile = new File(resultsFolder.fsName + "/" + filename);
    
    var max_wait_ms = 20000;
    var interval_ms = 500;
    var elapsed_ms = 0;
    writeToLog("Waiting for result file: " + resultFile.fsName);

    while (elapsed_ms < max_wait_ms) {
        if (resultFile.exists) {
            writeToLog("File found after " + elapsed_ms + "ms.");
            var resultDoc = app.open(resultFile);
            resultDoc.name = "ColorMatch_" + filename;
            alert("Gotowe! Color Matching zakończony.\n\nWynik został otwarty w nowym dokumencie.");
            return;
        }
        $.sleep(interval_ms);
        elapsed_ms += interval_ms;
    }
    throw new Error("Plik wynikowy nie istnieje (nawet po " + (max_wait_ms / 1000) + "s): " + resultFile.fsName);
}

function saveDocumentToTIFF(doc, folderPath, prefix) {
    writeToLog("Saving document '" + doc.name + "' to TIFF...");
    var activeDoc = app.activeDocument;
    app.activeDocument = doc;
    var filePath = new File(folderPath + "/" + prefix + "_" + Date.now() + ".tif");
    var tiffOptions = new TiffSaveOptions();
    tiffOptions.imageCompression = TIFFEncoding.NONE;
    tiffOptions.layers = false;
    doc.saveAs(filePath, tiffOptions, true, Extension.LOWERCASE);
    app.activeDocument = activeDoc;
    writeToLog("Saved successfully to: " + filePath.fsName);
    return filePath;
}

function cleanupFile(file) {
    if (file && file.exists) {
        try { 
            file.remove();
            writeToLog("Cleaned up temp file: " + file.fsName);
        } catch (e) {}
    }
}

main();
``````

#### palette_analyzer.jsx - ./app/scripts/palette_analyzer.jsx

``````
// GattoNero Palette Analyzer - Prosty format CSV
#target photoshop

// --- KONFIGURACJA ---
var SERVER_URL = "http://127.0.0.1:5000/api/analyze_palette";

function main() {
    if (app.documents.length === 0) {
        alert("Otwórz dokument, aby uruchomić skrypt.");
        return;
    }

    var doc = app.activeDocument;
    if (doc.layers.length === 0) {
        alert("Dokument nie zawiera żadnych warstw.");
        return;
    }

    var activeLayer = doc.activeLayer;
    
    // Zapytaj użytkownika o liczbę kolorów
    var k = prompt("Ile dominujących kolorów chcesz znaleźć?", 8, "Analizator Palety");
    if (k === null) {
        return; // Użytkownik anulował
    }
    k = parseInt(k);
    if (isNaN(k) || k < 1 || k > 50) {
        alert("Podaj liczbę między 1 a 50.");
        return;
    }

    alert("Analizuję paletę kolorów warstwy: \"" + activeLayer.name + "\"\nLiczba kolorów: " + k + "\n\nKliknij OK, aby rozpocząć analizę.");

    // Solidne ścieżki do folderów
    var scriptFile = new File($.fileName);
    var projectRoot = scriptFile.parent.parent; 
    var tempFolder = new Folder(projectRoot + "/temp_jsx");
    if (!tempFolder.exists) tempFolder.create();

    var sourceFile = null;
    
    try {
        // Zapisz aktywną warstwę do pliku TIFF
        sourceFile = saveLayerToPNG(doc, activeLayer, tempFolder, "palette_source");

        // Wyślij do serwera i otrzymaj paletę
        var response = executeCurl(sourceFile, k);
        
        // NOWY PROSTY PARSER - zamiast JSON używamy CSV
        var palette = parseSimpleResponse(response);
        
        // Wizualizuj paletę w dokumencie
        visualizePalette(doc, activeLayer, palette);
        
        alert("Gotowe! Paleta kolorów została wygenerowana.");

    } catch (e) {
        alert("Wystąpił błąd: \n" + e.message);
    } finally {
        // Posprzątaj po sobie
        cleanupFile(sourceFile);
    }
}

function parseSimpleResponse(response) {
    /**
     * Parsuje prostą odpowiedź w formacie:
     * success,4,255,0,0,0,255,255,0,255,0,0,0,255
     * lub
     * error,komunikat błędu
     */
    try {
        // Usuń białe znaki
        response = response.replace(/^\s+|\s+$/g, "");
        
        // Podziel po przecinkach
        var parts = response.split(",");
        
        if (parts.length < 1) {
            throw new Error("Pusta odpowiedź serwera");
        }
        
        var status = parts[0];
        
        if (status === "error") {
            var errorMessage = parts.length > 1 ? parts[1] : "Nieznany błąd";
            throw new Error("Błąd serwera: " + errorMessage);
        }
        
        if (status !== "success") {
            throw new Error("Nieznany status: " + status);
        }
        
        if (parts.length < 2) {
            throw new Error("Brak informacji o liczbie kolorów");
        }
        
        var colorCount = parseInt(parts[1]);
        if (isNaN(colorCount) || colorCount < 1) {
            throw new Error("Nieprawidłowa liczba kolorów: " + parts[1]);
        }
        
        // Sprawdź czy mamy odpowiednią liczbę wartości RGB
        var expectedValues = 2 + (colorCount * 3); // status + count + (r,g,b)*colorCount
        if (parts.length < expectedValues) {
            throw new Error("Za mało wartości kolorów. Oczekiwano: " + expectedValues + ", otrzymano: " + parts.length);
        }
        
        // Parsuj kolory
        var palette = [];
        for (var i = 0; i < colorCount; i++) {
            var r = parseInt(parts[2 + i * 3]);
            var g = parseInt(parts[3 + i * 3]);
            var b = parseInt(parts[4 + i * 3]);
            
            if (isNaN(r) || isNaN(g) || isNaN(b)) {
                throw new Error("Nieprawidłowe wartości RGB dla koloru " + (i + 1));
            }
            
            palette.push([r, g, b]);
        }
        
        return palette;
        
    } catch (e) {
        throw new Error("Błąd parsowania odpowiedzi: " + e.message + "\nOdpowiedź: " + response);
    }
}

// --- FUNKCJE POMOCNICZE ---

function saveLayerToPNG(doc, layer, folderPath, prefix) {
    var originalVisibility = [];
    var activeLayer = doc.activeLayer;

    // Zapisz obecny stan widoczności warstw
    for (var i = 0; i < doc.layers.length; i++) {
        originalVisibility.push({ layer: doc.layers[i], visible: doc.layers[i].visible });
    }

    var filePath = null;

    try {
        // Ukryj wszystkie warstwy oprócz analizowaneи
        for (var i = 0; i < originalVisibility.length; i++) {
            originalVisibility[i].layer.visible = false;
        }
        layer.visible = true;

        filePath = new File(folderPath + "/" + prefix + "_" + Date.now() + ".tif");
        var tiffOptions = new TiffSaveOptions();
        tiffOptions.imageCompression = TIFFEncoding.NONE;
        tiffOptions.byteOrder = ByteOrder.IBM;

        doc.saveAs(filePath, tiffOptions, true, Extension.LOWERCASE);
    } catch(e) {
        throw new Error("Błąd podczas zapisu warstwy do pliku TIFF: " + e.message);
    } finally {
        // Przywróć stan widoczności warstw
        for (var i = 0; i < originalVisibility.length; i++) {
            originalVisibility[i].layer.visible = originalVisibility[i].visible;
        }
        doc.activeLayer = activeLayer;
    }
    return filePath;
}

function executeCurl(sourceFile, k) {
    var command = 'curl -s -X POST ' +
                  '-F "source_image=@' + sourceFile.fsName + '" ' +
                  '-F "k=' + k + '" ' +
                  SERVER_URL;

    var result = "";
    var tempFolder = sourceFile.parent;

    if ($.os.indexOf("Windows") > -1) {
        var cmdFile = new File(tempFolder + "/photoshop_curl.cmd");
        var stdoutFile = new File(tempFolder + "/curl_stdout.txt");
        
        try {
            cmdFile.open("w");
            cmdFile.encoding = "UTF-8";
            cmdFile.writeln("@echo off");
            cmdFile.writeln(command);
            cmdFile.close();
            
            if (stdoutFile.exists) stdoutFile.remove();
            
            app.system('cmd /c ""' + cmdFile.fsName + '" > "' + stdoutFile.fsName + '""');
            
            // Oczekiwanie na odpowiedź serwera
            var maxWaitTime = 10000; // 10 sekund
            var waitInterval = 500;   // sprawdzaj co 0.5 sekundy
            var totalWait = 0;
            
            while (totalWait < maxWaitTime && (!stdoutFile.exists || stdoutFile.length === 0)) {
                $.sleep(waitInterval);
                totalWait += waitInterval;
            }

            if (stdoutFile.exists && stdoutFile.length > 0) {
                stdoutFile.open("r");
                result = stdoutFile.read();
                stdoutFile.close();
            }
        } finally {
            cleanupFile(cmdFile);
            cleanupFile(stdoutFile);
        }
    } else {
        result = app.doScript('do shell script "' + command + '"', Language.APPLESCRIPT);
    }

    // Własna implementacja trim() dla starszych wersji JSX
    var trimmedResult = result.replace(/^\s+|\s+$/g, "");
    if (trimmedResult === "") {
        throw new Error("Nie otrzymano odpowiedzi od serwera lub odpowiedź jest pusta. Upewnij się, że serwer jest uruchomiony.");
    }
    return result;
}

function visualizePalette(doc, sourceLayer, palette) {
    try {
        // Utwórz nową grupę warstw
        var layerSet = doc.layerSets.add();
        layerSet.name = "Analiza Palety - " + sourceLayer.name;
        
        // Utwórz nową warstwę w grupie dla kolorów
        doc.activeLayer = layerSet;
        var paletteLayer = doc.artLayers.add();
        paletteLayer.name = "Paleta Kolorów";
        
        // Konfiguracja wizualizacji - ładniejszy układ w siatce
        var squareSize = 80;  // większe kwadraty
        var spacing = 15;     // większy odstęp
        var startX = 100;     // pozycja startowa X
        var startY = 100;     // pozycja startowa Y
        var columns = 4;      // liczba kolumn w siatce
        
        // Iteruj przez kolory w palecie - układ w siatce
        for (var i = 0; i < palette.length; i++) {
            var color = palette[i];
            var r = color[0];
            var g = color[1];
            var b = color[2];
            
            // Ustaw kolor pierwszego planu w Photoshopie
            var foregroundColor = new SolidColor();
            foregroundColor.rgb.red = r;
            foregroundColor.rgb.green = g;
            foregroundColor.rgb.blue = b;
            app.foregroundColor = foregroundColor;
            
            // Oblicz pozycję kwadratu w siatce
            var x = startX + (i % columns) * (squareSize + spacing);
            var y = startY + Math.floor(i / columns) * (squareSize + spacing + 60); // +60 na etykiety
            
            // Utwórz zaznaczenie prostokątne
            var selectionArray = [
                [x, y],
                [x + squareSize, y],
                [x + squareSize, y + squareSize],
                [x, y + squareSize]
            ];
            doc.selection.select(selectionArray);
            
            // Wypełnij zaznaczenie kolorem
            doc.selection.fill(foregroundColor);
        }
        
        // Usuń zaznaczenie
        doc.selection.deselect();
        
        // Dodaj etykiety pod kwadratami - każda w nowej linii
        addColorLabels(doc, layerSet, palette, startX, startY, squareSize, spacing, columns);
        
    } catch (e) {
        throw new Error("Błąd podczas wizualizacji palety: " + e.message);
    }
}

function addColorLabels(doc, layerSet, palette, startX, startY, squareSize, spacing, columns) {
    try {
        for (var i = 0; i < palette.length; i++) {
            var color = palette[i];
            var r = color[0];
            var g = color[1];
            var b = color[2];
            
            // Konwertuj RGB na HEX
            var hex = "#" + 
                      ("0" + r.toString(16)).slice(-2) + 
                      ("0" + g.toString(16)).slice(-2) + 
                      ("0" + b.toString(16)).slice(-2);
            
            // Oblicz pozycję tekstu - środek kwadratu
            var x = startX + (i % columns) * (squareSize + spacing) + squareSize/2;
            var y = startY + Math.floor(i / columns) * (squareSize + spacing + 60); // +60 na etykiety
            
            // Numer koloru (nad kodem HEX)
            var numberLayer = doc.artLayers.add();
            numberLayer.kind = LayerKind.TEXT;
            numberLayer.name = "Numer " + (i + 1);
            
            var numberItem = numberLayer.textItem;
            numberItem.contents = (i + 1).toString();
            numberItem.position = [x, y + squareSize + 5];  // pod kwadratem
            numberItem.size = 14;
            numberItem.justification = Justification.CENTER;
            
            // Ustaw kolor tekstu na czarny
            var blackColor = new SolidColor();
            blackColor.rgb.red = 0;
            blackColor.rgb.green = 0;
            blackColor.rgb.blue = 0;
            numberItem.color = blackColor;
            
            // Kod HEX (pod numerem)
            var hexLayer = doc.artLayers.add();
            hexLayer.kind = LayerKind.TEXT;
            hexLayer.name = "HEX " + (i + 1);
            
            var hexItem = hexLayer.textItem;
            hexItem.contents = hex.toUpperCase();
            hexItem.position = [x, y + squareSize + 20];  // nieco niżej
            hexItem.size = 10;
            hexItem.justification = Justification.CENTER;
            hexItem.color = blackColor;
            
            // RGB (na samym dole)
            var rgbLayer = doc.artLayers.add();
            rgbLayer.kind = LayerKind.TEXT;
            rgbLayer.name = "RGB " + (i + 1);
            
            var rgbItem = rgbLayer.textItem;
            rgbItem.contents = "R:" + r + " G:" + g + " B:" + b;
            rgbItem.position = [x, y + squareSize + 35];  // jeszcze niżej
            rgbItem.size = 8;
            rgbItem.justification = Justification.CENTER;
            rgbItem.color = blackColor;
            
            // Przenieś wszystkie warstwy tekstowe do grupy
            numberLayer.move(layerSet, ElementPlacement.INSIDE);
            hexLayer.move(layerSet, ElementPlacement.INSIDE);
            rgbLayer.move(layerSet, ElementPlacement.INSIDE);
        }
    } catch (e) {
        // Jeśli dodawanie etykiet się nie powiedzie, nie przerywaj całego procesu
        alert("Ostrzeżenie: Nie udało się dodać etykiet tekstowych: " + e.message);
    }
}

function cleanupFile(file) {
    if (file && file.exists) {
        try {
            file.remove();
        } catch (e) {
            // Ignoruj błędy usuwania
        }
    }
}

// Konwersja liczby na hex (pomocnicza funkcja)
function toHex(n) {
    var hex = n.toString(16);
    return hex.length === 1 ? "0" + hex : hex;
}

// --- URUCHOMIENIE ---
main();

``````

#### test_simple.jsx - ./app/scripts/test_simple.jsx

``````
// Prosty test JSX
#target photoshop

try {
    alert("Test JSX działa!");
    
    // Test logowania
    var desktop = Folder.desktop;
    var logFile = new File(desktop + "/jsx_test.txt");
    logFile.open("w");
    logFile.writeln("JSX test działa: " + new Date());
    logFile.close();
    
    alert("Log zapisany na pulpicie!");
    
} catch (e) {
    alert("Błąd: " + e.message);
}

``````

---
