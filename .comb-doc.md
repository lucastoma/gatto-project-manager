# project name: Gatto Nero Ai Manager (Dokumentacja)

ROOT: d:\Unity\Projects\GattoNeroPhotoshop

---

## file tree list

### Found Files (5)
- .implementation-knowledge.md (\app\algorithms\algorithm_01_palette)
- .implementation-todo.md (\app\algorithms\algorithm_01_palette)
- gatto-WORKING-01-basic-photoshop-integration.md (\app\algorithms\algorithm_01_palette\doc)
- gatto-WORKING-01-core.md (\app\algorithms\algorithm_01_palette\doc)
- gatto-WORKING-02-api.md (\app\algorithms\algorithm_01_palette\doc)

---

## file content

### .implementation-knowledge.md - ./app/algorithms/algorithm_01_palette/.implementation-knowledge.md

``````
# Simple Palette Mapping - Podstawowe Mapowanie Palety

## quality control

Quality tester A: Problems found and correction applied to code snippets
->
Quality tester B: Problems found and correction applied
Quality tester B: Final review passed 2025-06-08 14:30 CEST

## 🟢 Poziom: Basic
**Trudność**: Niska | **Czas implementacji**: 1-2 godziny | **Złożoność**: O(n*m)

---

## Przegląd

Simple Palette Mapping to najbardziej podstawowy algorytm dopasowania kolorów, który mapuje każdy kolor z obrazu docelowego (target) na najbliższy kolor z palety wyciągniętej z obrazu wzorcowego (master). Algorytm wykorzystuje prostą metrykę odległości w przestrzeni RGB do znajdowania najlepszego dopasowania.

### Zastosowania
- Szybkie prototypowanie
- Podstawowe dopasowanie kolorów
- Edukacyjne przykłady
- Preprocessing dla bardziej zaawansowanych algorytmów

### Zalety
- ✅ Bardzo szybka implementacja
- ✅ Niskie zużycie pamięci
- ✅ Łatwe do zrozumienia
- ✅ Deterministyczne wyniki

### Wady
- ❌ Niska jakość dopasowania
- ❌ Brak uwzględnienia percepcji
- ❌ Może powodować artefakty
- ❌ Ograniczona kontrola

---

## Podstawy Teoretyczne

### Przestrzeń Kolorów RGB
Algorytm operuje w przestrzeni RGB, gdzie każdy kolor reprezentowany jest przez trzy składowe:
- **R** (Red): 0-255
- **G** (Green): 0-255  
- **B** (Blue): 0-255

### Metryka Odległości
Używana jest euklidesowa odległość w przestrzeni RGB z opcjonalnymi wagami percepcyjnymi:

```
# Prosta odległość euklidesowa
distance = √[(R₁-R₂)² + (G₁-G₂)² + (B₁-B₂)²]

# Ważona odległość (lepsze dopasowanie percepcyjne)
distance = √[(R₁-R₂)²×0.2126 + (G₁-G₂)²×0.7152 + (B₁-B₂)²×0.0722]
```

### Proces Mapowania
1. Wyciągnij paletę kolorów z obrazu **master** (wzorcowego)
2. Dla każdego piksela w obrazie **target** (docelowym)
3. Oblicz odległość do wszystkich kolorów w palecie master
4. Wybierz kolor o najmniejszej odległości
5. Zastąp piksel wybranym kolorem

---

## Pseudokod

```
FUNCTION simple_palette_mapping(master_image, target_image):
    master_palette = extract_palette(master_image)
    result_image = create_empty_image(target_image.size)
    
    FOR each pixel (x, y) in target_image:
        target_color = target_image.get_pixel(x, y)
        
        min_distance = INFINITY
        best_color = NULL
        
        FOR each color in master_palette:
            distance = calculate_rgb_distance(target_color, color)
            
            IF distance < min_distance:
                min_distance = distance
                best_color = color
        
        result_image.set_pixel(x, y, best_color)
    
    RETURN result_image

FUNCTION calculate_rgb_distance(color1, color2):
    dr = color1.r - color2.r
    dg = color1.g - color2.g
    db = color1.b - color2.b
    
    RETURN sqrt(dr*dr + dg*dg + db*db)
```

---

## Implementacja Python

Pełna implementacja klasy `PaletteMappingAlgorithm` znajduje się w pliku `app/algorithms/algorithm_01_palette/algorithm.py`.

---

## Parametry i Konfiguracja

### Podstawowe Parametry
- **num_colors**: Liczba kolorów w palecie master (domyślnie: 16)
- **distance_metric**: 'euclidean' lub 'weighted_rgb' (domyślnie: weighted_rgb)
- **thumbnail_size**: Rozmiar miniaturki dla wyciągania palety (domyślnie: 100x100)
- **use_vectorized**: Czy używać szybkiej wersji NumPy (domyślnie: True)

### Przykład konfiguracji JSON
```json
{
    "num_colors": 20,
    "distance_metric": "weighted_rgb",
    "use_cache": true,
    "preprocess": true,
    "thumbnail_size": [150, 150],
    "use_vectorized": true,
    "cache_max_size": 15000
}
```

### Optymalizacje
```python
# Szybsza wersja z numpy vectorization
def fast_palette_mapping(source_array, palette):
    # Reshape obrazu do listy pikseli
    pixels = source_array.reshape(-1, 3)
    
    # Oblicz odległości dla wszystkich pikseli naraz
    distances = np.sqrt(np.sum((pixels[:, None] - palette[None, :]) ** 2, axis=2))
    
    # Znajdź najbliższe kolory
    closest_indices = np.argmin(distances, axis=1)
    
    # Mapuj kolory
    result_pixels = palette[closest_indices]
    
    # Przywróć kształt obrazu
    return result_pixels.reshape(source_array.shape)
```

---

## Analiza Wydajności

### Złożoność Obliczeniowa
- **Czasowa**: O(W × H × P), gdzie W=szerokość, H=wysokość, P=rozmiar palety
- **Pamięciowa**: O(W × H + P + C), gdzie C=rozmiar cache

### Benchmarki (Poprawione)
| Rozmiar obrazu | Rozmiar palety | Czas (naive) | Czas (vectorized) | Speedup | Pamięć |
|----------------|----------------|--------------|-------------------|---------|---------|
| 512×512        | 16             | 0.8s         | 0.08s            | 10x     | ~50MB   |
| 1024×1024      | 16             | 3.2s         | 0.32s            | 10x     | ~200MB  |
| 2048×2048      | 32             | 14.1s        | 1.41s            | 10x     | ~800MB  |

### Optymalizacje
1. **Numpy vectorization** - 5-10x szybciej
2. **Zmniejszenie rozmiaru palety** - liniowa poprawa
3. **Preprocessing obrazu** - redukcja rozmiaru
4. **Parallel processing** - wykorzystanie wielu rdzeni

---

## Ocena Jakości

### Metryki
- **PSNR**: Zwykle 15-25 dB
- **SSIM**: 0.3-0.6
- **Delta E**: Wysokie wartości (>10)
- **Perceptual**: Niska jakość

### Przykładowe Wyniki
```
Test Image: landscape.jpg (1024x768)
Target Palette: sunset.jpg (16 colors)

Wyniki:
- PSNR: 18.4 dB
- SSIM: 0.42
- Średnie Delta E: 15.8
- Czas przetwarzania: 2.1s
- Jakość percepcyjna: 3/10
```

---

## Przypadki Użycia

### 1. Szybkie Prototypowanie
```python
# Szybki test koncepcji
mapper = SimplePaletteMapping()
result = mapper.process_images("test.jpg", "palette.jpg", "quick_test.jpg")
```

### 2. Preprocessing
```python
# Przygotowanie danych dla zaawansowanych algorytmów
basic_result = mapper.apply_mapping(source, palette)
# Następnie użyj advanced_algorithm(basic_result)
```

### 3. Edukacja
```python
# Demonstracja podstawowych konceptów
for student_image in student_images:
    result = mapper.process_images(student_image, reference_palette, f"result_{i}.jpg")
    show_comparison(student_image, result)
```

---

## Rozwiązywanie Problemów

### Częste Problemy

#### 1. Artefakty kolorystyczne
**Problem**: Ostre przejścia między kolorami
**Rozwiązanie**: 
- Zwiększ rozmiar palety
- Użyj preprocessing (blur)
- Przejdź na zaawansowany algorytm

#### 2. Niska jakość
**Problem**: Wynik daleki od oryginału
**Rozwiązanie**:
- Sprawdź jakość palety docelowej
- Użyj lepszej metryki odległości
- Rozważ LAB color space

#### 3. Wolne przetwarzanie
**Problem**: Długi czas wykonania
**Rozwiązanie**:
```python
# Użyj numpy vectorization
def optimized_mapping(source, palette):
    return fast_palette_mapping(np.array(source), np.array(palette))
```

#### 4. Błędy pamięci
**Problem**: OutOfMemoryError dla dużych obrazów
**Rozwiązanie**:
```python
# Przetwarzanie w blokach
def process_in_chunks(image, palette, chunk_size=1000):
    height, width = image.shape[:2]
    for y in range(0, height, chunk_size):
        chunk = image[y:y+chunk_size]
        # Przetwórz chunk
```

---

## Przyszłe Ulepszenia

### Krótkoterminowe (v1.1)
- [ ] Numpy vectorization dla lepszej wydajności
- [ ] Wsparcie dla różnych formatów obrazów
- [ ] Progress bar z tqdm
- [ ] Lepsze error handling

### Średnioterminowe (v1.2)
- [ ] Weighted RGB distance
- [ ] Adaptive palette size
- [ ] Multi-threading support
- [ ] Memory optimization

### Długoterminowe (v2.0)
- [ ] Przejście na LAB color space
- [ ] Integration z advanced algorithms
- [ ] GPU acceleration (CUDA)
- [ ] Real-time preview

---

## Testy Jednostkowe (Ulepszone)

Pełna implementacja testów jednostkowych dla klasy `PaletteMappingAlgorithm` znajduje się w pliku `app/algorithms/algorithm_01_palette/tests.py`.

---

## Bibliografia i Referencje

1. **Color Theory Basics**
   - Fairchild, M. D. (2013). Color appearance models. John Wiley & Sons.
   
2. **Image Processing**
   - Gonzalez, R. C., & Woods, R. E. (2017). Digital image processing. Pearson.
   
3. **Python Libraries**
   - PIL/Pillow Documentation
   - NumPy User Guide
   - OpenCV Python Tutorials

---

**Autor**: GattoNero AI Assistant  
**Data utworzenia**: 2024-01-20  
**Ostatnia aktualizacja**: 2024-01-20  
**Wersja**: 1.0  
**Status**: ✅ Gotowy do implementacji

---

## Główne Zmiany Wprowadzone

### 🔄 **1. Odwrócenie Kierunku Mapowania**
- **Było**: `extract_palette(target_path)` → `apply_mapping(source_path, palette)`
- **Jest**: `extract_palette(master_path)` → `apply_mapping(target_path, palette)`
- **Logika**: "Nadaj stylowi obrazu TARGET kolorystykę z obrazu MASTER"

### ⚡ **2. Ulepszone Wagi Percepcyjne**
- Zastąpiono uproszczone wagi (0.3, 0.59, 0.11) standardem **ITU-R BT.709**
- Nowe wagi: R=0.2126, G=0.7152, B=0.0722 (bardziej precyzyjne)

### 🧪 **3. Kompletne Testy Jednostkowe**
- Programowe tworzenie obrazów testowych (10x10 z 4 kolorami)
- Testy niezależne od zewnętrznych plików
- Walidacja wszystkich głównych funkcji

### 🛡️ **4. Lepsza Kontrola Pamięci**
- Cache z ograniczeniem rozmiaru (`cache_max_size`)
- Automatyczne czyszczenie cache przy przekroczeniu limitu
- Wyraźne komunikaty o rozmiarach przetwarzanych obrazów

### 📊 **5. Rozszerzona Analiza Jakości**
- Funkcja `analyze_mapping_quality()` dla statystyk
- Porównanie liczby unikalnych kolorów przed/po
- Średnie i maksymalne różnice RGB

### 💾 **6. Metadane w Plikach PNG**
- Zapisywanie informacji o algorytmie w pliku wynikowym
- Śledzenie źródłowych plików i parametrów
- Data przetwarzania dla audytu

Wszystkie sugerowane zmiany zostały zaimplementowane, a kod jest teraz zgodny z logicznym workflow: **Master (wzorzec stylu) → Target (obraz do transformacji) → Result**.

---

``````

### .implementation-todo.md - ./app/algorithms/algorithm_01_palette/.implementation-todo.md

``````
# TODO: Implementacja Algorithm 01: Palette Mapping

## FAZA 1: Migracja i Adaptacja Kodu
- [ ] Stworzenie brakujących plików w module: `algorithm.py`, `config.py`, `tests.py`.
- [ ] Skopiowanie klasy `SimplePaletteMapping` z `.implementation-knowledge.md` do pliku `algorithm.py`.
- [ ] Adaptacja klasy w `algorithm.py`:
    - [ ] Poprawienie importów, aby pasowały do nowej struktury (np. `from app.core...`).
    - [ ] Dodanie inicjalizacji logera i profilera w metodzie `__init__`.
    - [ ] Zmiana nazwy klasy na `PaletteMappingAlgorithm`, aby pasowała do konwencji.
- [ ] Stworzenie funkcji-fabryki `create_palette_mapping_algorithm()` w `algorithm.py`.

## FAZA 2: Integracja z Systemem
- [ ] Zaktualizowanie pliku `app/algorithms/algorithm_01_palette/__init__.py`, aby eksportował nową klasę i fabrykę.
- [ ] Weryfikacja, czy algorytm jest poprawnie dodany do `ALGORITHM_REGISTRY` w `app/algorithms/__init__.py`.
- [ ] Weryfikacja, czy `algorithm_map` w `app/api/routes.py` poprawnie mapuje `method: '1'` na `algorithm_01_palette`.

## FAZA 3: Testowanie
- [ ] Implementacja testów jednostkowych w `tests.py`, dziedziczących po `BaseAlgorithmTestCase`.
- [ ] Napisanie testu weryfikującego poprawność ekstrakcji palety.
- [ ] Napisanie testu weryfikującego poprawność mapowania kolorów.
- [ ] Napisanie testu sprawdzającego obsługę błędnych parametrów (np. `k_colors` poza zakresem).
- [ ] Uruchomienie i potwierdzenie, że wszystkie nowe testy przechodzą pomyślnie.
- [ ] Uruchomienie testów integracyjnych (`test_algorithm_integration.py`) i potwierdzenie, że system wciąż działa spójnie.

## FAZA 4: Finalizacja i Czyszczenie
- [ ] Edycja pliku `.implementation-knowledge.md`:
    - [ ] Usunięcie pełnej implementacji klasy Pythona.
    - [ ] Pozostawienie jedynie teorii, pseudokodu i kluczowych fragmentów.
    - [ ] Dodanie linku/referencji do pliku `algorithm.py` jako finalnego źródła prawdy o kodzie.
- [ ] Usunięcie starego, źródłowego dokumentu `gatto-WORKING-03...md` z folderu `doc/`, aby uniknąć duplikacji.
``````

### gatto-WORKING-01-basic-photoshop-integration.md - ./app/algorithms/algorithm_01_palette/doc/gatto-WORKING-01-basic-photoshop-integration.md

``````
# GattoNero AI Assistant - Basic Photoshop Integration
## Podstawowa Integracja JSX dla 3 Algorytmów Color Matching

> **Status:** ✅ BASIC JSX INTEGRATION  
> **Ostatnia aktualizacja:** 2024-12-19  
> **Podstawa:** Przetestowane skrypty `palette_analyzer.jsx`, `color_matcher.jsx`, `test_simple.jsx`

---

## 🎯 FILOZOFIA BASIC INTEGRATION

### Dlaczego BASIC?
- **Prostota:** Minimum kodu, maksimum funkcjonalności
- **Skuteczność:** Przetestowane rozwiązania, sprawdzone protokoły
- **CSV over JSON:** Prostszy parsing, mniej błędów
- **Jeden plik = jedna funkcja:** Modularność i łatwość debugowania

### Zakres Funkcjonalny
- ✅ **3 Algorytmy Color Matching** (Palette, Statistical, Histogram)
- ✅ **Analiza Palety Kolorów** (K-means clustering)
- ✅ **File Management** (TIFF export/import)
- ✅ **Error Handling** (Robust error reporting)

---

## 📁 STRUKTURA SKRYPTÓW JSX

### Verified Scripts
```
app/scripts/
├── palette_analyzer.jsx    # ✅ Analiza palety kolorów (CSV protocol)
├── color_matcher.jsx       # ✅ Color matching 3 metod (CSV protocol)  
└── test_simple.jsx         # ✅ Basic connectivity test
```

### Usunięte/Niepoprawne
- ❌ `client.jsx` - USUNIĘTY (niepoprawny protokół JSON)

---

## 🔄 PROTOKÓŁ WYMIANY DANYCH

### Format CSV (Ustalony Standard)
**Dlaczego CSV?**
- Prostszy parsing niż JSON
- Mniej podatny na błędy składni
- Szybszy transfer danych
- Łatwiejszy debugging

### API Response Formats

#### `/api/analyze_palette` Response:
```csv
success,{count},{r,g,b,r,g,b,...}
```
**Przykład:**
```csv
success,3,255,128,64,100,200,50,75,175,225
```

#### `/api/colormatch` Response:
```csv
success,method{X},{filename}
```
**Przykład:**
```csv
success,method1,test_simple_1749392883_matched.tif
```

#### Error Response (obie metody):
```csv
error,{error_message}
```

---

## 🎨 PATTERN: Color Matching (color_matcher.jsx)

### Główny Workflow
```jsx
1. Configuration Dialog → wybór master/target docs + metoda
2. Export Documents → TIFF files w temp_jsx/
3. HTTP Request → curl POST multipart/form-data
4. Parse CSV Response → success,method{X},{filename}
5. Import Result → otwórz wynikowy plik w PS
6. Cleanup → usuń pliki tymczasowe
```

### Kluczowe Funkcje

#### showConfigurationDialog()
```jsx
// Centralne okno wyboru:
// - Master document (dropdown)
// - Target document (dropdown)  
// - Method (1: Palette, 2: Statistical, 3: Histogram)
// - K colors parameter (dla metody 1)
```

#### parseColorMatchResponse()
```jsx
// CSV Parser:
// Input:  "success,method1,result_file.tif"
// Output: { status: "success", method: "method1", filename: "result_file.tif" }
```

#### executeCurl()
```jsx
// HTTP Request:
// Windows: cmd batch file + stdout capture
// macOS: AppleScript shell command
// Parametry: master_image, target_image, method, k
```

---

## 🎨 PATTERN: Palette Analysis (palette_analyzer.jsx)

### Główny Workflow
```jsx
1. Active Layer Selection → bieżąca warstwa
2. K Colors Input → prompt użytkownika (1-50)
3. Export Layer → TIFF file w temp_jsx/
4. HTTP Request → curl POST multipart/form-data
5. Parse CSV Response → success,{count},{r,g,b,...}
6. Create Color Swatches → nowa paleta w PS
7. Cleanup → usuń pliki tymczasowe
```

### Kluczowe Funkcje

#### parseSimpleResponse()
```jsx
// CSV Parser dla palety:
// Input:  "success,3,255,128,64,100,200,50,75,175,225"
// Output: [[255,128,64], [100,200,50], [75,175,225]]
```

#### saveLayerToPNG()
```jsx
// Export pojedynczej warstwy:
// - Ukryj wszystkie inne warstwy
// - Zapisz jako TIFF
// - Przywróć widoczność warstw
```

#### createColorSwatches()
```jsx
// Wizualizacja palety:
// - Nowy dokument 400x100px
// - Prostokąty kolorów
// - Nazwa z wartościami RGB
```

---

## 🛠️ ZASADY KONSTRUKCJI JSX

### 1. Error Handling Pattern
```jsx
try {
    // Main workflow
    var result = processImage();
    alert("SUCCESS: " + result);
} catch (e) {
    alert("ERROR: " + e.message);
} finally {
    // Cleanup files
    cleanupFile(tempFile);
}
```

### 2. File Management Pattern
```jsx
// Temporary files w temp_jsx/
var tempFolder = new Folder(projectRoot + "/temp_jsx");
if (!tempFolder.exists) tempFolder.create();

// Timestamp naming
var fileName = prefix + "_" + Date.now() + ".tif";

// Cleanup after use
function cleanupFile(file) {
    if (file && file.exists) {
        try { file.remove(); } catch (e) { /* ignore */ }
    }
}
```

### 3. Document Export Pattern
```jsx
// TIFF Save Options (standard)
var tiffOptions = new TiffSaveOptions();
tiffOptions.imageCompression = TIFFEncoding.NONE; // Bezstratnie
tiffOptions.layers = false; // Spłaszczony obraz

doc.saveAs(filePath, tiffOptions, true, Extension.LOWERCASE);
```

### 4. HTTP Request Pattern (Windows)
```jsx
// curl command przez CMD batch file
var cmdFile = new File(tempFolder + "/command.cmd");
var stdoutFile = new File(tempFolder + "/output.txt");

cmdFile.open("w");
cmdFile.writeln("@echo off");
cmdFile.writeln(curlCommand);
cmdFile.close();

app.system('cmd /c ""' + cmdFile.fsName + '" > "' + stdoutFile.fsName + '""');

// Wait for response with timeout
var maxWaitTime = 15000; // 15 sekund
// ... polling logic ...
```

---

## 📊 PARAMETRY I KONFIGURACJA

### Server Configuration
```jsx
var SERVER_URL = "http://127.0.0.1:5000/api/colormatch"; // lub analyze_palette
```

### Method Parameters
- **Method 1 (Palette):** `k` colors (4-32, default: 8)
- **Method 2 (Statistical):** brak dodatkowych parametrów
- **Method 3 (Histogram):** brak dodatkowych parametrów

### File Paths
```jsx
var projectRoot = new File($.fileName).parent.parent; // GattoNeroPhotoshop/
var tempFolder = projectRoot + "/temp_jsx/";          // temp files
var resultsFolder = projectRoot + "/results/";        // wyniki
```

---

## ⚡ OPTYMALIZACJE I BEST PRACTICES

### Performance
- **TIFF Format:** Bezstratny, szybki zapis/odczyt
- **Single Layer Export:** Tylko aktywna warstwa (palette_analyzer)
- **Timeout Handling:** 15s limit dla HTTP requests
- **Immediate Cleanup:** Usuwanie plików tymczasowych

### User Experience
- **Configuration Dialog:** Wszystkie parametry w jednym oknie
- **Progress Feedback:** Alert messages o postępie
- **Error Messages:** Szczegółowe informacje o błędach
- **File Validation:** Sprawdzanie istnienia plików

### Security
- **Path Validation:** Kontrola ścieżek plików
- **Input Sanitization:** Walidacja parametrów użytkownika
- **File Cleanup:** Automatyczne usuwanie temp files
- **Error Isolation:** Try-catch dla każdej operacji

---

## 🧪 TESTING WORKFLOW

### test_simple.jsx
```jsx
// Basic connectivity test:
// 1. Alert message
// 2. File write test (desktop log)
// 3. Exception handling verification
```

### Verification Steps
1. **JSX Engine:** `test_simple.jsx` - podstawowy test działania
2. **HTTP Connection:** `palette_analyzer.jsx` - test API komunikacji  
3. **Full Workflow:** `color_matcher.jsx` - test kompletnego procesu

---

## 🎯 ROZWÓJ I ROZSZERZENIA

### Priorytet 1: Stabilność
- [ ] Batch processing (multiple files)
- [ ] Progress bars dla długich operacji
- [ ] Configuration persistence (user preferences)
- [ ] Advanced error recovery

### Priorytet 2: UI/UX
- [ ] Drag & drop file support
- [ ] Preview thumbnails w dialog
- [ ] Real-time parameter preview
- [ ] Keyboard shortcuts

### Priorytet 3: Integration
- [ ] Photoshop Actions integration
- [ ] Bridge integration
- [ ] Preset management system
- [ ] Automated workflows

---

## 📝 TEMPLATE JSX SCRIPT

### Minimal Working Example
```jsx
#target photoshop

var SERVER_URL = "http://127.0.0.1:5000/api/endpoint";

function main() {
    try {
        // 1. Validate input
        if (app.documents.length === 0) {
            throw new Error("Open a document first");
        }
        
        // 2. Setup paths
        var projectRoot = new File($.fileName).parent.parent;
        var tempFolder = new Folder(projectRoot + "/temp_jsx");
        if (!tempFolder.exists) tempFolder.create();
        
        // 3. Export file
        var tempFile = exportDocument(app.activeDocument, tempFolder);
        
        // 4. HTTP request
        var response = executeCurl(tempFile);
        
        // 5. Parse response
        var result = parseCSVResponse(response);
        
        // 6. Process result
        processResult(result);
        
        alert("SUCCESS!");
        
    } catch (e) {
        alert("ERROR: " + e.message);
    } finally {
        cleanupFile(tempFile);
    }
}

main();
```

---

*Ten dokument opisuje podstawową integrację JSX dla systemu GattoNero AI Assistant, opartą na przetestowanych skryptach i ustalonych protokołach komunikacji.*

``````

### gatto-WORKING-01-core.md - ./app/algorithms/algorithm_01_palette/doc/gatto-WORKING-01-core.md

``````
# **GattoNero AI Assistant – Kompletna Dokumentacja Systemu i SOP**

**Status:** ✅ SYSTEM W PEŁNI OPERACYJNY – ZWERYFIKOWANO 08.06.2025  
**Ostatnia aktualizacja:** 08.06.2025  
**Wersja managera:** `server_manager_enhanced.py v2.2.0`

---

## 1. **Architektura i Stack Technologiczny**

### Struktura Projektu (Aktualna)

Struktura została zrefaktoryzowana, aby wspierać modularne algorytmy i solidną infrastrukturę.

```
GattoNeroPhotoshop/
├── app/
│   ├── algorithms/               # ✅ Nowy modularny system algorytmów
│   │   ├── algorithm_01_palette/
│   │   ├── ...
│   ├── api/
│   │   └── routes.py             # ✅ Endpointy API
│   ├── core/                     # ✅ Rdzeń infrastruktury (logger, profiler, monitor)
│   │   ├── development_logger.py
│   │   ├── performance_profiler.py
│   │   └── health_monitor_simple.py
│   ├── scripts/                  # ✅ Skrypty integracyjne dla Adobe Photoshop
│   └── server.py                 # ✅ Główna aplikacja serwera Flask
│
├── logs/                         # ✅ Automatycznie tworzone logi (serwera, managera)
├── results/                      # ✅ Wyniki działania algorytmów
├── uploads/                      # ✅ Tymczasowe pliki
│
├── run_server.py                 # ✅ Skrypt uruchamiający aplikację Flask
├── server_manager_enhanced.py    # ✅ **GŁÓWNE NARZĘDZIE DO ZARZĄDZANIA SERWEREM**
├── server_config.json            # ✅ Konfiguracja serwera i managera
│
├── test_basic.py                 # ✅ Podstawowe testy funkcjonalne API
└── test_algorithm_integration.py # ✅ Testy integracji modularnych algorytmów
```

### Stack Technologiczny (Zweryfikowany)

- **Backend:** Python 3.x + Flask  
- **Computer Vision:** OpenCV (cv2)  
- **Machine Learning:** scikit-learn (K-means)  
- **Narzędzia systemowe:** psutil, requests  
- **Frontend / Integracja:** Adobe CEP (ExtendScript .jsx, HTML/JS)

---

## 2. **Niezawodny Cykl Pracy z Serwerem (SOP)**

Poniżej znajduje się procedura gwarantująca stabilne i przewidywalne środowisko pracy.

### Krok 1: Uruchomienie Serwera w Tle

W głównym folderze projektu uruchom:

```sh
python server_manager_enhanced.py start
```

- **Co się dzieje?** Manager uruchamia serwer Flask w odłączonym procesie, sprawdza poprawność startu i zwalnia terminal.

### Krok 2: Weryfikacja Statusu

Aby sprawdzić, czy serwer działa:

```sh
python server_manager_enhanced.py status
```

- **Poprawny wynik:** Dwie linie `[SUCCESS]`: RUNNING (PID: ...) i RESPONDING.

### Krok 3: Praca i Testowanie

- **Szybki test funkcjonalny:**  
	`python test_basic.py`
- **Test integracji nowych algorytmów:**  
	`python test_algorithm_integration.py`
- **Praca z Photoshopem:** Serwer gotowy na zapytania ze skryptów `.jsx`.

### Krok 4: Zatrzymanie Serwera

Po zakończeniu pracy zatrzymaj serwer:

```sh
python server_manager_enhanced.py stop
```

### Krok 5: Diagnostyka (Gdy coś pójdzie nie tak)

Sprawdź logi błędów:

```sh
python server_manager_enhanced.py logs --file errors
```

- Komenda pokaże dokładny błąd Pythona, który spowodował awarię.

---

## 3. **Kompletny Opis Managera Serwera (`server_manager_enhanced.py`)**

To narzędzie jest centrum dowodzenia. Poniżej wszystkie możliwości:

### `start` – Uruchamianie serwera

```sh
python server_manager_enhanced.py start [opcje]
```

**Opcje:**
- `--auto-restart` – Watchdog automatycznie restartuje serwer po awarii.
- `--no-wait` – Natychmiast zwalnia terminal, nie czeka na pełny start.
- `--port PORT` – Uruchamia serwer na innym porcie.

### `stop` – Zatrzymywanie serwera

```sh
python server_manager_enhanced.py stop [opcje]
```

**Opcje:**
- `--force` – Natychmiastowe zatrzymanie procesu (gdy standardowe nie działa).

### `restart` – Restartowanie serwera

```sh
python server_manager_enhanced.py restart [opcje]
```

**Opcje:**
- `--auto-restart` – Włącza watchdoga po restarcie.

### `status` – Sprawdzanie statusu

```sh
python server_manager_enhanced.py status [opcje]
```

**Opcje:**
- `--detailed` – Dodatkowe informacje: pamięć, CPU, uptime.

### `logs` – Przeglądanie logów

```sh
python server_manager_enhanced.py logs [opcje]
```

**Opcje:**
- `--file [manager|server|errors]` – Wybór pliku logu.
	- `manager`: Logi managera.
	- `server`: Wyjście serwera Flask.
	- `errors`: **Najważniejsze do debugowania**.
- `--tail N` – Ostatnie N linii (domyślnie 20).

### `watch` – Monitoring na żywo

```sh
python server_manager_enhanced.py watch [opcje]
```

**Opcje:**
- `--interval N` – Interwał odświeżania w sekundach (domyślnie 5).

---

## 4. **Konfiguracja (`server_config.json`)**

Manager i serwer są w pełni konfigurowalne przez plik `server_config.json`. Jeśli plik nie istnieje, zostanie utworzony automatycznie.

**Kluczowe opcje:**
- `server.python_executable` – Ścieżka do interpretera Pythona (można ustawić ręcznie).
- `server.startup_command` – Komenda startowa serwera (domyślnie `["<python_exe>", "run_server.py"]`).
- `logging.log_dir` – Folder na logi.

---

Dzięki tej dokumentacji masz solidny fundament do implementacji i testowania kolejnych zaawansowanych algorytmów.
``````

### gatto-WORKING-02-api.md - ./app/algorithms/algorithm_01_palette/doc/gatto-WORKING-02-api.md

``````
# GattoNero AI Assistant - WORKING DOCUMENTATION
## Część 2: API & Photoshop Integration - Działające Interfejsy

> **Status:** ✅ DZIAŁAJĄCE API  
> **Ostatnia aktualizacja:** 2024  
> **Poprzedni:** `gatto-WORKING-01-core.md`

---

## 🌐 REST API SPECIFICATION

### Base Configuration
- **Host:** `127.0.0.1`
- **Port:** `5000`
- **Protocol:** HTTP
- **Base URL:** `http://127.0.0.1:5000`
- **Content-Type:** `multipart/form-data` (uploads), `application/json` (responses)

---

## 📡 ENDPOINTS DOCUMENTATION

### ✅ `/api/analyze_palette` (POST)

#### Opis
Analiza palety kolorów z przesłanego obrazu przy użyciu algorytmu K-means.

#### Request
```http
POST /api/analyze_palette HTTP/1.1
Host: 127.0.0.1:5000
Content-Type: multipart/form-data

--boundary
Content-Disposition: form-data; name="image"; filename="test.jpg"
Content-Type: image/jpeg

[binary image data]
--boundary--
```

#### Parameters
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `image` | File | ✅ | Plik obrazu (JPEG, PNG, TIFF) |
| `k` | Integer | ❌ | Liczba kolorów w palecie (default: 8) |

#### Response (Success)
```json
{
  "status": "success",
  "palette": [
    {"r": 255, "g": 128, "b": 64, "hex": "#ff8040"},
    {"r": 120, "g": 200, "b": 100, "hex": "#78c864"},
    // ... więcej kolorów
  ],
  "colors_count": 8,
  "processing_time": 0.15
}
```

#### Response (Error)
```json
{
  "status": "error",
  "message": "No image file provided",
  "error_code": "MISSING_FILE"
}
```

#### Curl Example
```bash
curl -X POST \
  http://127.0.0.1:5000/api/analyze_palette \
  -F "image=@test_image.jpg" \
  -F "k=12"
```

---

### ✅ `/api/colormatch` (POST)

#### Opis
Color matching między obrazem wzorcowym (master) a docelowym (target) przy użyciu wybranej metody.

#### Request
```http
POST /api/colormatch HTTP/1.1
Host: 127.0.0.1:5000
Content-Type: multipart/form-data

--boundary
Content-Disposition: form-data; name="master"; filename="master.tif"
Content-Type: image/tiff

[binary master image]
--boundary
Content-Disposition: form-data; name="target"; filename="target.tif"
Content-Type: image/tiff

[binary target image]
--boundary
Content-Disposition: form-data; name="method"

2
--boundary--
```

#### Parameters
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `master` | File | ✅ | Obraz wzorcowy (źródło kolorów) |
| `target` | File | ✅ | Obraz docelowy (do przekształcenia) |
| `method` | Integer | ✅ | Metoda (1, 2, lub 3) |
| `k` | Integer | ❌ | Liczba kolorów dla metody 1 (default: 16) |

#### Dostępne Metody
| Method | Name | Description | Speed | Quality |
|--------|------|-------------|-------|----------|
| `1` | Simple Palette Mapping | K-means RGB clustering | 🟡 Medium | 🟢 Stylized |
| `2` | Basic Statistical Transfer | LAB statistics matching | 🟢 Fast | 🟢 Natural |
| `3` | Simple Histogram Matching | Luminance histogram | 🟢 Fast | 🟢 Exposure |

#### Response (Success)
```json
{
  "status": "success",
  "method": 2,
  "method_name": "Basic Statistical Transfer",
  "result_file": "test_simple_1749375027_matched.tif",
  "result_path": "app/temp_jsx/test_simple_1749375027_matched.tif",
  "processing_time": 0.01,
  "input_files": {
    "master": "master_1749375027.tif",
    "target": "target_1749375027.tif"
  }
}
```

#### Response (Error)
```json
{
  "status": "error",
  "message": "Invalid method. Use 1, 2, or 3",
  "error_code": "INVALID_METHOD",
  "available_methods": [1, 2, 3]
}
```

#### Curl Example
```bash
curl -X POST \
  http://127.0.0.1:5000/api/colormatch \
  -F "master=@master.tif" \
  -F "target=@target.tif" \
  -F "method=2"
```

---

## 🔧 ERROR HANDLING

### Standard Error Codes
| Code | Description | HTTP Status |
|------|-------------|-------------|
| `MISSING_FILE` | Brak wymaganego pliku | 400 |
| `INVALID_FORMAT` | Nieprawidłowy format obrazu | 400 |
| `INVALID_METHOD` | Nieprawidłowa metoda | 400 |
| `PROCESSING_ERROR` | Błąd podczas przetwarzania | 500 |
| `FILE_SAVE_ERROR` | Błąd zapisu wyniku | 500 |
| `INTERNAL_ERROR` | Wewnętrzny błąd serwera | 500 |

### Error Response Format
```json
{
  "status": "error",
  "message": "Human readable error message",
  "error_code": "MACHINE_READABLE_CODE",
  "details": {
    "additional": "context",
    "if": "needed"
  }
}
```

---

## 🎨 PHOTOSHOP INTEGRATION

### CEP Panel Architecture
**Lokalizacja:** `app/scripts/`

#### ✅ Główne Skrypty

##### `client.jsx` - Main CEP Panel
```javascript
// Główny interfejs użytkownika
// HTML/CSS/JavaScript + ExtendScript bridge
// Komunikacja z Python API
```

##### `color_matcher.jsx` - Color Matching Interface
```javascript
// Dedykowany interfejs dla color matching
// Wybór warstw, parametrów metody
// Preview i apply funkcjonalności
```

##### `palette_analyzer.jsx` - Palette Analysis
```javascript
// Analiza palet kolorów
// Wizualizacja wyników
// Export palet do swatches
```

##### `test_simple.jsx` - Integration Tests
```javascript
// Testy integracyjne PS ↔ Python
// Walidacja komunikacji
// Debug utilities
```

### Workflow Integration

#### 1. Export Phase (PS → Python)
```javascript
// 1. Użytkownik wybiera warstwy/obrazy w PS
var masterLayer = app.activeDocument.activeLayer;
var targetLayer = getSelectedLayer();

// 2. Export do TIFF (bezstratny)
var masterFile = exportToTIFF(masterLayer, "master_" + timestamp + ".tif");
var targetFile = exportToTIFF(targetLayer, "target_" + timestamp + ".tif");

// 3. Przygotowanie danych dla API
var formData = new FormData();
formData.append("master", masterFile);
formData.append("target", targetFile);
formData.append("method", selectedMethod);
```

#### 2. Processing Phase (Python)
```python
# 1. Odbiór plików przez Flask
master_file = request.files['master']
target_file = request.files['target']
method = int(request.form['method'])

# 2. Przetwarzanie algorytmem
result_path = process_color_matching(master_file, target_file, method)

# 3. Zwrócenie ścieżki wyniku
return jsonify({
    "status": "success",
    "result_file": result_path
})
```

#### 3. Import Phase (Python → PS)
```javascript
// 1. Odbiór odpowiedzi z API
var response = JSON.parse(httpResponse);
var resultFile = response.result_file;

// 2. Import wyniku do PS
var resultDoc = app.open(new File(resultFile));

// 3. Opcjonalne: kopiowanie do oryginalnego dokumentu
copyLayerToDocument(resultDoc, originalDoc);

// 4. Cleanup plików tymczasowych
cleanupTempFiles([masterFile, targetFile]);
```

---

## 📁 FILE MANAGEMENT

### Temporary Files Structure
```
app/temp_jsx/
├── master_1749375027.tif          # Obraz wzorcowy
├── target_1749375027.tif          # Obraz docelowy  
├── test_simple_1749375027_matched.tif # Wynik color matching
└── palette_source_1749372754913.tif   # Analiza palety
```

### Naming Convention
- **Pattern:** `{type}_{timestamp}[_{suffix}].{ext}`
- **Types:** `master`, `target`, `palette_source`
- **Suffixes:** `matched`, `analyzed`, `processed`
- **Timestamp:** Unix timestamp dla unikalności

### File Lifecycle
1. **Upload:** CEP → multipart form → Flask
2. **Processing:** Temporary storage w `app/temp_jsx/`
3. **Result:** Nowy plik z wynikiem
4. **Download:** CEP pobiera wynik
5. **Cleanup:** Automatyczne lub manualne usunięcie

---

## ⚡ PERFORMANCE METRICS

### API Response Times (Rzeczywiste)
| Endpoint | Method | Image Size | Avg Time | Status |
|----------|--------|------------|----------|--------|
| `/api/analyze_palette` | - | 1MP | 150ms | ✅ |
| `/api/colormatch` | 1 | 1MP | 190ms | ✅ |
| `/api/colormatch` | 2 | 1MP | 10ms | ✅ ⚡ |
| `/api/colormatch` | 3 | 1MP | 20ms | ✅ |

### Throughput
- **Concurrent requests:** 1 (single-threaded Flask)
- **Max file size:** 50MB (configurable)
- **Supported formats:** JPEG, PNG, TIFF
- **Memory usage:** ~2x image size

---

## 🔒 SECURITY CONSIDERATIONS

### Input Validation
```python
# File type validation
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'tiff', 'tif'}

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

# File size limits
app.config['MAX_CONTENT_LENGTH'] = 50 * 1024 * 1024  # 50MB

# Filename sanitization
import werkzeug.utils
safe_filename = werkzeug.utils.secure_filename(filename)
```

### Network Security
- **Localhost only:** Bind do 127.0.0.1
- **No authentication:** Development mode
- **CORS:** Disabled (same-origin)
- **HTTPS:** Not implemented (localhost)

---

## 🧪 API TESTING

### Manual Testing
```bash
# Test server health
curl http://127.0.0.1:5000/api/analyze_palette

# Test palette analysis
curl -X POST \
  -F "image=@test_image.jpg" \
  http://127.0.0.1:5000/api/analyze_palette

# Test color matching
curl -X POST \
  -F "master=@master.tif" \
  -F "target=@target.tif" \
  -F "method=2" \
  http://127.0.0.1:5000/api/colormatch
```

### Automated Testing
**Plik:** `test_basic.py`
```python
# Test wszystkich metod color matching
for method in [1, 2, 3]:
    response = test_method(method)
    assert response['status'] == 'success'
    assert os.path.exists(response['result_path'])
```

### Integration Testing
**Plik:** `test_curl.py`
```python
# HTTP integration tests
# Multipart form testing
# Error handling validation
```

---

## 📊 MONITORING & DEBUGGING

### Server Logs
```
 * Serving Flask app 'app.api.routes'
 * Debug mode: off
 * Running on http://127.0.0.1:5000
127.0.0.1 - - [timestamp] "POST /api/colormatch HTTP/1.1" 200 -
```

### Request Debugging
```python
# Enable debug mode for detailed logs
app.run(debug=True)

# Custom logging
import logging
logging.basicConfig(level=logging.DEBUG)
```

### Health Checks
```python
# Server status check
def check_server_health():
    try:
        response = requests.get('http://127.0.0.1:5000/api/analyze_palette')
        return response.status_code in [200, 400, 405]
    except:
        return False
```

---

## 🚀 DEPLOYMENT CONSIDERATIONS

### Development Server (Current)
```python
# Flask development server
app.run(host='127.0.0.1', port=5000, debug=False)
```

### Production Recommendations
```bash
# WSGI server (future)
gunicorn --bind 127.0.0.1:5000 app.api.routes:app

# Process management
supervisord configuration

# Reverse proxy
nginx configuration for static files
```

---

## 📝 API CHANGELOG

### v1.0 (Current)
- ✅ `/api/analyze_palette` - Palette analysis
- ✅ `/api/colormatch` - Color matching (methods 1-3)
- ✅ Multipart file uploads
- ✅ JSON responses
- ✅ Error handling

### v1.1 (Planned)
- [ ] `/api/methods` - List available methods
- [ ] `/api/status` - Server health endpoint
- [ ] Progress reporting for long operations
- [ ] Batch processing support

---

## 🔗 RELATED DOCUMENTATION

- **Core System:** `gatto-WORKING-01-core.md`
- **Server Management:** `METHODOLOGY.md`
- **Testing Guide:** `TESTING_GUIDE.md`
- **Concepts:** `color-matching-IDEAS-*.md`

---

*Ten dokument opisuje rzeczywiście działające API i integrację z Photoshopem. Wszystkie endpointy zostały przetestowane i są gotowe do użycia.*
``````
