Główną i jedyną przyczyną losowych wyników jest fakt, że interfejs WebView **jest na stałe skonfigurowany do używania danych testowych (mock data)**, które celowo wprowadzają losowość, zamiast wywoływać właściwy, deterministyczny algorytm analizy.

---

## Analiza i diagnoza problemu

Śledząc przepływ danych z interfejsu WebView (`/webview/api/process`), dochodzimy do pliku `app/webview/routes.py`. Znajduje się w nim kluczowa flaga, która całkowicie zmienia zachowanie aplikacji:

**Plik:** `./app/webview/routes.py`

```python
# === ZMIANA: WPROWADZAMY JAWNĄ FLAGĘ DO KONTROLOWANIA DANYCH TESTOWYCH ===
# Ustaw na 'False', gdy dodasz brakujące moduły 'core' i 'algorithms'
USE_MOCK_DATA = True
```

Ponieważ flaga `USE_MOCK_DATA` jest ustawiona na `True`, funkcja `process_algorithm_01` nigdy nie wywołuje prawdziwej logiki z `app/algorithms`. Zamiast tego, natychmiast wywołuje funkcję `create_mock_palette_result`.

Funkcja ta, mimo że próbuje bazować na kolorach z obrazka, **celowo wprowadza losowe wartości**:

**Plik:** `./app/webview/routes.py`

```python
def create_mock_palette_result(params, image_path):
    # ... (logika pobierania bazowych kolorów) ...
    for r, g, b in base_colors:
        # Dodajmy lekką losowość, aby nie były to zawsze te same kolory z getcolors
        r = min(255, max(0, r + random.randint(-10, 10)))
        g = min(255, max(0, g + random.randint(-10, 10)))
        b = min(255, max(0, b + random.randint(-10, 10)))
        colors.append({
            # ...
            'percentage': random.uniform(5, 25)
        })
    # ...
```

**Wnioski:**

1.  **Źródło losowości:** Funkcje `random.randint()` i `random.uniform()` w `create_mock_palette_result` są bezpośrednią przyczyną obserwowanych różnic w wynikach.
2.  **Brak wywołania algorytmu:** Prawdziwy algorytm K-Means z `random_state=0` (który jest deterministyczny) nigdy nie jest uruchamiany przez interfejs WebView.
3.  **Metoda "Median Cut":** Ta metoda nie jest w ogóle zaimplementowana w logice algorytmu. Wybór tej opcji w interfejsie nie ma żadnego efektu – nadal wywoływana jest ta sama funkcja generująca losowe dane.

---

## Proponowane rozwiązanie (zapewnienie 100% powtarzalności)

Aby naprawić problem i podłączyć interfejs do prawdziwych, deterministycznych algorytmów, należy wykonać poniższe kroki.

### Krok 1: Wyłączenie danych testowych w `routes.py`

Pierwszym i najważniejszym krokiem jest przełączenie flagi, aby aplikacja zaczęła używać prawdziwej logiki.

**Plik:** `app/webview/routes.py`
**Modyfikacja:** Zmień wartość `USE_MOCK_DATA` na `False`.

```python
# Before
USE_MOCK_DATA = True

# After
USE_MOCK_DATA = False
```

### Krok 2: Implementacja "Median Cut" i refaktoryzacja `algorithm.py`

Musimy zaimplementować brakującą metodę "Median Cut" i dostosować funkcję `extract_palette`, aby obsługiwała obie metody (`kmeans` i `median_cut`). Najprostszym sposobem na deterministyczny Median Cut jest użycie biblioteki Pillow.

**Plik:** `app/algorithms/algorithm_01_palette/algorithm.py`
**Modyfikacja:** Zastąp całą funkcję `extract_palette` poniższą wersją.

```python
    def extract_palette(self, image_path, num_colors=None, method='kmeans'):
        """
        Extracts a color palette from an image using either K-means or Median Cut.
        """
        if num_colors is None:
            num_colors = self.config['num_colors']

        try:
            image = Image.open(image_path)
            if image.mode == 'RGBA':
                background = Image.new('RGB', image.size, (255, 255, 255))
                background.paste(image, mask=image.split()[-1])
                image = background
            elif image.mode != 'RGB':
                image = image.convert('RGB')

            original_size = image.size
            quality = self.config.get('quality', 5)
            base_size = 100
            max_size = 1000
            thumbnail_size_val = int(base_size + (max_size - base_size) * (quality - 1) / 9.0)

            self.logger.info(f"Analyzing with quality {quality}/10 (thumbnail: {thumbnail_size_val}px) using '{method}' method.")

            # --- NOWA LOGIKA WYBORU METODY ---
            if method == 'median_cut':
                # Użyj Pillow's quantize dla deterministycznego Median Cut
                temp_image = image.copy()
                temp_image.thumbnail((thumbnail_size_val, thumbnail_size_val))

                # Quantize do N kolorów
                quantized_image = temp_image.quantize(colors=num_colors, method=Image.MEDIANCUT, dither=Image.NONE)

                # Wyciągnij paletę z obrazka po kwantyzacji
                palette_raw = quantized_image.getpalette()
                palette = []
                for i in range(num_colors):
                    r = palette_raw[i*3]
                    g = palette_raw[i*3+1]
                    b = palette_raw[i*3+2]
                    palette.append([r, g, b])

            else: # Domyślnie użyj K-Means
                image.thumbnail((thumbnail_size_val, thumbnail_size_val))
                img_array = np.array(image)
                pixels = img_array.reshape(-1, 3)

                # Użyj random_state=0 dla deterministycznego wyniku K-Means
                kmeans = KMeans(n_clusters=num_colors, random_state=0, n_init=10)
                kmeans.fit(pixels)
                palette = kmeans.cluster_centers_.astype(int).tolist()

            # --- KONIEC NOWEJ LOGIKI ---

            palette = [[max(0, min(255, c)) for c in color_val] for color_val in palette]

            if self.config.get('inject_extremes', False):
                self.logger.info("Injecting pure black and white into the palette.")
                if [0, 0, 0] not in palette: palette.insert(0, [0, 0, 0])
                if [255, 255, 255] not in palette: palette.insert(0, [255, 255, 255])

            self.validate_palette(palette)
            self.logger.info(f"Extracted {len(palette)} colors from image {original_size} -> {image.size}")
            return palette

        except Exception as e:
            self.logger.error(f"Error extracting palette from {image_path}: {e}", exc_info=True)
            return [[0,0,0], [255,255,255], [128,128,128]]

```

### Krok 3: Aktualizacja logiki `routes.py` do wywoływania nowego algorytmu

Teraz, gdy algorytm jest gotowy, musimy zmodyfikować `app/webview/routes.py`, aby poprawnie go wywoływał i formatował odpowiedź.

**Plik:** `app/webview/routes.py`
**Modyfikacja:**

1.  Popraw importy.
2.  Zastąp funkcję `process_algorithm_01` nową wersją.

```python
# Zmień importy na górze pliku
# ...
if not USE_MOCK_DATA:
    try:
        # Zamiast ImageProcessor, importujemy bezpośrednio algorytm
        from ..algorithms.algorithm_01_palette.algorithm import PaletteMappingAlgorithm
    except ImportError as e:
        raise ImportError(f"Nie udało się zaimportować modułów. Upewnij się, że istnieją. Błąd: {e}")
else:
    # ... reszta bez zmian
    PaletteMappingAlgorithm = None
# ...

# Zastąp całą funkcję process_algorithm_01
def process_algorithm_01(image_path, params):
    """Process Algorithm 01 - Palette extraction using the actual algorithm."""
    # Ta funkcja jest teraz wywoływana tylko, gdy USE_MOCK_DATA = False
    try:
        # 1. Inicjalizuj algorytm
        algorithm = PaletteMappingAlgorithm()

        # 2. Przekaż parametry z UI do konfiguracji algorytmu
        algorithm.config['quality'] = params.get('quality', 5)

        # 3. Wywołaj właściwą funkcję ekstrakcji palety
        palette_rgb = algorithm.extract_palette(
            image_path=image_path,
            num_colors=params['num_colors'],
            method=params['method']
        )

        # 4. Przetwórz wynik do formatu oczekiwanego przez UI (z HEX, HSL itp.)
        # Ta część jest opcjonalna, ale dobra dla spójności z mock data
        colors = []
        for r, g, b in palette_rgb:
            hex_color = f"#{r:02x}{g:02x}{b:02x}"
            colors.append({
                'hex': hex_color,
                'rgb': [r, g, b],
                'hsl': rgb_to_hsl(r, g, b)
                # Procentowy udział wymagałby dodatkowej logiki, więc pomijamy go dla uproszczenia
            })

        return {
            'palette': colors,
            'algorithm': 'algorithm_01',
            'method': params['method'],
            'num_colors': params['num_colors'],
            'quality': params['quality'],
            'mock': False  # Wyraźnie zaznaczamy, że to nie są dane testowe
        }

    except Exception as e:
        # Użyj loggera, jeśli jest dostępny
        if hasattr(current_app, 'logger'):
            current_app.logger.error(f"Algorithm 01 real processing error: {e}", exc_info=True)
        else:
            print(f"Algorithm 01 real processing error: {e}")
        raise ValueError(f"Błąd przetwarzania algorytmu: {str(e)}")

```

Po wprowadzeniu tych trzech zmian, interfejs WebView będzie w pełni podłączony do backendowego algorytmu, który teraz poprawnie obsługuje zarówno metodę K-Means, jak i Median Cut w sposób w 100% deterministyczny i powtarzalny.
