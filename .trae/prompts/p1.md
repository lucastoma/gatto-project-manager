"""WebView Routes

Flask routes for the WebView interface.
Provides web-based testing and debugging for algorithms.
"""

import os
import json
from datetime import datetime
from flask import Blueprint, render_template, request, jsonify, current_app, send_from_directory
from werkzeug.utils import secure_filename
from werkzeug.exceptions import RequestEntityTooLarge

# --- UWAGA: Upewniamy się, że używamy prawdziwego algorytmu ---

# Zakładamy, że reszta aplikacji jest poprawnie skonfigurowana.

try:
from ..algorithms.algorithm_01_palette.algorithm import PaletteMappingAlgorithm
except ImportError as e: # W przypadku błędu importu, rzucamy wyjątek, aby wyraźnie pokazać problem
raise ImportError(f"CRITICAL: Failed to import PaletteMappingAlgorithm. Ensure the module exists and is correct. Error: {e}")

# Create Blueprint

webview_bp = Blueprint('webview', **name**,
template_folder='templates',
static_folder='static',
url_prefix='/webview')

# --- NOWA KONFIGURACJA ZGODNA Z PROŚBĄ ---

# Zwiększony limit rozmiaru pliku (np. do 100MB)

MAX_FILE_SIZE = 100 _ 1024 _ 1024

# Dodane rozszerzenia TIF/TIFF i usunięte limity

ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'tif', 'tiff'}

# Używamy podkatalogu w 'static', aby pliki były publicznie dostępne przez URL

RESULTS_FOLDER = os.path.join(os.path.dirname(**file**), 'static', 'results')

# Używamy osobnego folderu na tymczasowe pliki

UPLOADS_FOLDER = os.path.join(os.path.dirname(**file**), 'temp_uploads')

def allowed_file(filename):
"""Sprawdza, czy rozszerzenie pliku jest dozwolone."""
return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def ensure_folders():
"""Upewnia się, że foldery na upload i wyniki istnieją."""
os.makedirs(UPLOADS_FOLDER, exist_ok=True)
os.makedirs(RESULTS_FOLDER, exist_ok=True)

def log_activity(action, details=None, level='info'):
"""Prosta funkcja do logowania aktywności WebView."""
timestamp = datetime.now().isoformat()
log_message = f"WebView: {action} - {json.dumps(details) if details else ''}"
if hasattr(current_app, 'logger'):
if level == 'error':
current_app.logger.error(log_message)
else:
current_app.logger.info(log_message)
else:
print(f"[{level.upper()}] {log_message}")

# --- Istniejące trasy ---

@webview_bp.route('/')
def index():
"""WebView main page."""
return render_template('index.html')

@webview_bp.route('/algorithm_01')
def algorithm_01_palette_extraction():
"""Strona testowania ekstrakcji palety (istniejąca)."""
log_activity('page_view', {'page': 'algorithm_01_palette_extraction'})
return render_template('algorithm_01_palette_extraction.html')

# --- NOWA TRASA DO TESTOWANIA TRANSFERU PALETY ---

@webview_bp.route('/algorithm_01/transfer')
def algorithm_01_palette_transfer():
"""Strona testowania transferu palety (nowa)."""
log_activity('page_view', {'page': 'algorithm_01_palette_transfer'})
return render_template('algorithm_01_transfer.html')

@webview_bp.route('/results/<filename>')
def get_result_file(filename):
"""Serwuje przetworzony obraz z folderu wyników."""
return send_from_directory(RESULTS_FOLDER, filename)

# --- NOWA TRASA API DO OBSŁUGI TRANSFERU PALETY ---

@webview_bp.route('/api/algorithm_01/transfer', methods=['POST'])
def handle_palette_transfer():
"""
Przyjmuje obraz master, target i parametry, przetwarza je i zwraca
ścieżkę do obrazu wynikowego.
"""
ensure_folders()
log_activity('transfer_request_start')

    try:
        # Sprawdzenie plików
        if 'master_image' not in request.files or 'target_image' not in request.files:
            log_activity('transfer_error', {'error': 'Missing master or target image'}, 'error')
            return jsonify({'success': False, 'error': 'Brak pliku master_image lub target_image'}), 400

        master_file = request.files['master_image']
        target_file = request.files['target_image']

        if master_file.filename == '' or target_file.filename == '':
             return jsonify({'success': False, 'error': 'Nie wybrano plików'}), 400

        if not allowed_file(master_file.filename) or not allowed_file(target_file.filename):
            return jsonify({'success': False, 'error': f'Niedozwolony typ pliku. Dozwolone: {", ".join(ALLOWED_EXTENSIONS)}'}), 400

        # Zapisanie plików tymczasowych
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        master_filename = f"{timestamp}_master_{secure_filename(master_file.filename)}"
        target_filename = f"{timestamp}_target_{secure_filename(target_file.filename)}"
        master_path = os.path.join(UPLOADS_FOLDER, master_filename)
        target_path = os.path.join(UPLOADS_FOLDER, target_filename)
        master_file.save(master_path)
        target_file.save(target_path)
        log_activity('files_saved', {'master': master_path, 'target': target_path})

        # Zebranie parametrów z formularza
        params = {
            'num_colors': int(request.form.get('num_colors', 16)),
            'dithering_method': request.form.get('dithering_method', 'none'),
            'inject_extremes': request.form.get('inject_extremes') == 'on',
            'preserve_extremes': request.form.get('preserve_extremes') == 'on',
            'extremes_threshold': int(request.form.get('extremes_threshold', 10)),
            'edge_blur_enabled': request.form.get('edge_blur_enabled') == 'on',
            'edge_detection_threshold': float(request.form.get('edge_detection_threshold', 25)),
            'edge_blur_radius': float(request.form.get('edge_blur_radius', 1.5)),
            'edge_blur_strength': float(request.form.get('edge_blur_strength', 0.3)),
            # Inne parametry, które mogą być potrzebne
            'quality': int(request.form.get('quality', 5)),
            'distance_metric': request.form.get('distance_metric', 'weighted_rgb')
        }
        log_activity('parameters_collected', params)

        # Przetwarzanie
        algorithm = PaletteMappingAlgorithm()
        output_filename = f"result_{target_filename}"
        output_path = os.path.join(RESULTS_FOLDER, output_filename)

        log_activity('processing_start')
        success = algorithm.process_images(
            master_path=master_path,
            target_path=target_path,
            output_path=output_path,
            **params
        )
        log_activity('processing_end', {'success': success})

        if not success:
            raise RuntimeError("Algorithm processing failed. Check server logs for details.")

        # Zwrócenie ścieżki do pliku wynikowego
        result_url = f"/webview/results/{output_filename}"
        log_activity('transfer_request_success', {'result_url': result_url})

        return jsonify({
            'success': True,
            'result_url': result_url,
            'message': 'Obraz przetworzony pomyślnie!'
        })

    except Exception as e:
        log_activity('transfer_error', {'error': str(e)}, 'error')
        if hasattr(current_app, 'logger'):
            current_app.logger.exception("An error occurred during palette transfer.")
        return jsonify({'success': False, 'error': f'Wystąpił wewnętrzny błąd serwera: {str(e)}'}), 500
    finally:
        # Opcjonalne czyszczenie plików upload, jeśli to pożądane
        # W tym przypadku zostawiamy je do debugowania
        pass
