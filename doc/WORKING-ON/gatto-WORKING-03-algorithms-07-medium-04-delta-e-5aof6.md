# Delta E Color Distance - Czƒô≈õƒá 5a: CIEDE2000 - Implementacja Podstawowa

## üî¥ Poziom: Advanced
**Trudno≈õƒá**: Wysoka | **Czas implementacji**: 4-6 godzin | **Z≈Ço≈ºono≈õƒá**: O(1) - skomplikowana

---

## Wprowadzenie do CIEDE2000

### Historia i Znaczenie

CIEDE2000 (Delta E 2000) to najnowsza i najbardziej zaawansowana formu≈Ça do obliczania r√≥≈ºnic kolor√≥w, wprowadzona przez CIE w 2001 roku. Jest to kulminacja dziesiƒôcioleci bada≈Ñ nad percepcjƒÖ kolor√≥w przez cz≈Çowieka.

### Kluczowe Innowacje CIEDE2000

- **Funkcje korekcyjne** dla wszystkich sk≈Çadowych (L*, C*, H*)
- **Interakcja miƒôdzy sk≈Çadowymi** - uwzglƒôdnienie wzajemnych wp≈Çyw√≥w
- **Korekcja obrotu** (RT) dla niebieskich kolor√≥w
- **Najlepsza korelacja** z ocenƒÖ wizualnƒÖ cz≈Çowieka
- **Kompleksowe funkcje wagowe** dostosowane do percepcji

### Por√≥wnanie z Poprzednimi Metodami

| Aspekt | CIE76 | CIE94 | CIEDE2000 |
|--------|-------|-------|----------|
| Rok wprowadzenia | 1976 | 1994 | 2001 |
| Z≈Ço≈ºono≈õƒá formu≈Çy | Bardzo prosta | ≈örednia | Bardzo wysoka |
| Funkcje wagowe | Brak | Podstawowe | Zaawansowane |
| Korekcja obrotu | Brak | Brak | Tak (RT) |
| Interakcja sk≈Çadowych | Brak | Ograniczona | Pe≈Çna |
| Dok≈Çadno≈õƒá percepcyjna | Niska | ≈örednia | Najwy≈ºsza |
| Czas oblicze≈Ñ | Najszybszy | Szybki | Najwolniejszy |

---

## Matematyczne Podstawy CIEDE2000

### Formu≈Ça G≈Ç√≥wna

```
ŒîE‚ÇÄ‚ÇÄ = ‚àö[(ŒîL'/kL¬∑SL)¬≤ + (ŒîC'/kC¬∑SC)¬≤ + (ŒîH'/kH¬∑SH)¬≤ + RT¬∑(ŒîC'/kC¬∑SC)¬∑(ŒîH'/kH¬∑SH)]
```

### Kluczowe Sk≈Çadowe

#### 1. Przekszta≈Çcenia Wstƒôpne

**≈örednia jasno≈õƒá:**
```
LÃÑ = (L‚ÇÅ* + L‚ÇÇ*) / 2
```

**Korekcja a* (uwzglƒôdnienie chromatyczno≈õci):**
```
CÃÑ* = (C‚ÇÅ* + C‚ÇÇ*) / 2
G = 0.5 √ó (1 - ‚àö(CÃÑ*‚Å∑ / (CÃÑ*‚Å∑ + 25‚Å∑)))
a‚ÇÅ' = (1 + G) √ó a‚ÇÅ*
a‚ÇÇ' = (1 + G) √ó a‚ÇÇ*
```

**Nowe warto≈õci chromatyczno≈õci i odcienia:**
```
C‚ÇÅ' = ‚àö(a‚ÇÅ'¬≤ + b‚ÇÅ*¬≤)
C‚ÇÇ' = ‚àö(a‚ÇÇ'¬≤ + b‚ÇÇ*¬≤)
h‚ÇÅ' = atan2(b‚ÇÅ*, a‚ÇÅ') √ó 180/œÄ
h‚ÇÇ' = atan2(b‚ÇÇ*, a‚ÇÇ') √ó 180/œÄ
```

#### 2. R√≥≈ºnice Podstawowe

```
ŒîL' = L‚ÇÇ* - L‚ÇÅ*
ŒîC' = C‚ÇÇ' - C‚ÇÅ'
Œîh' = h‚ÇÇ' - h‚ÇÅ' (z uwzglƒôdnieniem cykliczno≈õci)
ŒîH' = 2 √ó ‚àö(C‚ÇÅ' √ó C‚ÇÇ') √ó sin(Œîh'/2 √ó œÄ/180)
```

#### 3. ≈örednie Warto≈õci

```
LÃÑ' = (L‚ÇÅ* + L‚ÇÇ*) / 2
CÃÑ' = (C‚ÇÅ' + C‚ÇÇ') / 2
hÃÑ' = (h‚ÇÅ' + h‚ÇÇ') / 2 (z uwzglƒôdnieniem cykliczno≈õci)
```

#### 4. Funkcje Wagowe

**SL (waga jasno≈õci):**
```
SL = 1 + (0.015 √ó (LÃÑ' - 50)¬≤) / ‚àö(20 + (LÃÑ' - 50)¬≤)
```

**SC (waga chromatyczno≈õci):**
```
SC = 1 + 0.045 √ó CÃÑ'
```

**SH (waga odcienia):**
```
T = 1 - 0.17√ócos(hÃÑ'-30¬∞) + 0.24√ócos(2√óhÃÑ') + 0.32√ócos(3√óhÃÑ'+6¬∞) - 0.20√ócos(4√óhÃÑ'-63¬∞)
SH = 1 + 0.015 √ó CÃÑ' √ó T
```

#### 5. Funkcja Korekcji Obrotu (RT)

```
ŒîŒ∏ = 30 √ó exp(-((hÃÑ' - 275)/25)¬≤)
RC = 2 √ó ‚àö(CÃÑ'‚Å∑ / (CÃÑ'‚Å∑ + 25‚Å∑))
RT = -sin(2 √ó ŒîŒ∏ √ó œÄ/180) √ó RC
```

---

## Implementacja CIEDE2000

### Struktury Danych

```python
import math
import numpy as np
from typing import Tuple, List, Optional, Union
from dataclasses import dataclass
from enum import Enum

@dataclass
class CIEDE2000Parameters:
    """Parametry dla obliczenia CIEDE2000"""
    kL: float = 1.0  # Waga jasno≈õci
    kC: float = 1.0  # Waga chromatyczno≈õci
    kH: float = 1.0  # Waga odcienia
    
    @classmethod
    def standard(cls) -> 'CIEDE2000Parameters':
        """Standardowe parametry CIEDE2000"""
        return cls(kL=1.0, kC=1.0, kH=1.0)
    
    @classmethod
    def custom(cls, kL: float, kC: float, kH: float) -> 'CIEDE2000Parameters':
        """Niestandardowe parametry"""
        return cls(kL=kL, kC=kC, kH=kH)

@dataclass
class CIEDE2000IntermediateValues:
    """Warto≈õci po≈õrednie oblicze≈Ñ CIEDE2000"""
    # Warto≈õci wej≈õciowe
    L1: float
    a1: float
    b1: float
    L2: float
    a2: float
    b2: float
    
    # ≈örednie warto≈õci
    L_bar: float
    C_bar_initial: float
    
    # Korekcja G
    G: float
    
    # Skorygowane warto≈õci a'
    a1_prime: float
    a2_prime: float
    
    # Nowe chromatyczno≈õci i odcienie
    C1_prime: float
    C2_prime: float
    h1_prime: float
    h2_prime: float
    
    # R√≥≈ºnice
    delta_L_prime: float
    delta_C_prime: float
    delta_h_prime: float
    delta_H_prime: float
    
    # ≈örednie skorygowane
    L_bar_prime: float
    C_bar_prime: float
    h_bar_prime: float
    
    # Funkcje wagowe
    SL: float
    SC: float
    SH: float
    T: float
    
    # Korekcja obrotu
    delta_theta: float
    RC: float
    RT: float
    
    # Sk≈Çadowe finalne
    L_component: float
    C_component: float
    H_component: float
    interaction_term: float
    
    # Wynik ko≈Ñcowy
    delta_E: float

@dataclass
class CIEDE2000Result:
    """Wynik obliczenia Delta E CIEDE2000"""
    delta_e: float
    color1_lab: Tuple[float, float, float]
    color2_lab: Tuple[float, float, float]
    parameters: CIEDE2000Parameters
    intermediate_values: Optional[CIEDE2000IntermediateValues]
    interpretation: str
    
    def __str__(self):
        return f"ŒîE‚ÇÄ‚ÇÄ: {self.delta_e:.3f} ({self.interpretation})"
    
    def detailed_breakdown(self) -> str:
        """Zwraca szczeg√≥≈Çowy rozk≈Çad r√≥≈ºnic"""
        if self.intermediate_values is None:
            return f"ŒîE‚ÇÄ‚ÇÄ: {self.delta_e:.3f} - {self.interpretation}"
        
        iv = self.intermediate_values
        return f"""CIEDE2000 Detailed Breakdown:
‚îú‚îÄ ŒîE‚ÇÄ‚ÇÄ: {self.delta_e:.3f}
‚îú‚îÄ Sk≈Çadowe:
‚îÇ  ‚îú‚îÄ L': {iv.delta_L_prime:.3f} (SL={iv.SL:.3f})
‚îÇ  ‚îú‚îÄ C': {iv.delta_C_prime:.3f} (SC={iv.SC:.3f})
‚îÇ  ‚îú‚îÄ H': {iv.delta_H_prime:.3f} (SH={iv.SH:.3f})
‚îÇ  ‚îî‚îÄ RT: {iv.RT:.3f} (korekcja obrotu)
‚îú‚îÄ Funkcje wagowe:
‚îÇ  ‚îú‚îÄ T: {iv.T:.3f}
‚îÇ  ‚îú‚îÄ G: {iv.G:.3f}
‚îÇ  ‚îî‚îÄ RC: {iv.RC:.3f}
‚îú‚îÄ Sk≈Çadowe wa≈ºone:
‚îÇ  ‚îú‚îÄ L-component: {iv.L_component:.3f}
‚îÇ  ‚îú‚îÄ C-component: {iv.C_component:.3f}
‚îÇ  ‚îú‚îÄ H-component: {iv.H_component:.3f}
‚îÇ  ‚îî‚îÄ Interaction: {iv.interaction_term:.3f}
‚îî‚îÄ Interpretacja: {self.interpretation}"""
    
    def component_contributions(self) -> dict:
        """Oblicza wk≈Çad poszczeg√≥lnych sk≈Çadowych"""
        if self.intermediate_values is None:
            return {'L*': 0, 'C*': 0, 'H*': 0, 'Interaction': 0}
        
        iv = self.intermediate_values
        total_squared = (iv.L_component**2 + iv.C_component**2 + 
                        iv.H_component**2 + abs(iv.interaction_term))
        
        if total_squared > 0:
            return {
                'L*': (iv.L_component**2 / total_squared) * 100,
                'C*': (iv.C_component**2 / total_squared) * 100,
                'H*': (iv.H_component**2 / total_squared) * 100,
                'Interaction': (abs(iv.interaction_term) / total_squared) * 100
            }
        else:
            return {'L*': 0, 'C*': 0, 'H*': 0, 'Interaction': 0}
```

### G≈Ç√≥wna Klasa Kalkulatora

```python
class CIEDE2000Calculator:
    """Kalkulator Delta E CIEDE2000"""
    
    def __init__(self, parameters: Optional[CIEDE2000Parameters] = None):
        """
        Inicjalizuje kalkulator CIEDE2000
        
        Args:
            parameters: Parametry CIEDE2000 (domy≈õlnie standardowe)
        """
        self.parameters = parameters or CIEDE2000Parameters.standard()
        self.method_name = "CIEDE2000"
        self.year_introduced = 2001
        self.description = "Najbardziej zaawansowana formu≈Ça Delta E z korekcjƒÖ obrotu"
    
    def calculate(self, color1: Tuple[float, float, float], 
                 color2: Tuple[float, float, float],
                 return_details: bool = False,
                 include_intermediate: bool = False) -> Union[float, CIEDE2000Result]:
        """
        Oblicza Delta E CIEDE2000 miƒôdzy dwoma kolorami LAB
        
        Args:
            color1: Pierwszy kolor (L*, a*, b*)
            color2: Drugi kolor (L*, a*, b*)
            return_details: Czy zwr√≥ciƒá szczeg√≥≈Çowe informacje
            include_intermediate: Czy do≈ÇƒÖczyƒá warto≈õci po≈õrednie
        
        Returns:
            Warto≈õƒá Delta E lub obiekt CIEDE2000Result
        """
        # Walidacja
        self._validate_lab_color(color1, "color1")
        self._validate_lab_color(color2, "color2")
        
        # Rozpakowanie kolor√≥w
        L1, a1, b1 = color1
        L2, a2, b2 = color2
        
        # Krok 1: Obliczenie ≈õredniej jasno≈õci
        L_bar = (L1 + L2) / 2.0
        
        # Krok 2: Obliczenie poczƒÖtkowej chromatyczno≈õci
        C1_initial = math.sqrt(a1**2 + b1**2)
        C2_initial = math.sqrt(a2**2 + b2**2)
        C_bar_initial = (C1_initial + C2_initial) / 2.0
        
        # Krok 3: Obliczenie G (korekcja a*)
        C_bar_7 = C_bar_initial**7
        G = 0.5 * (1 - math.sqrt(C_bar_7 / (C_bar_7 + 25**7)))
        
        # Krok 4: Skorygowane warto≈õci a'
        a1_prime = (1 + G) * a1
        a2_prime = (1 + G) * a2
        
        # Krok 5: Nowe chromatyczno≈õci
        C1_prime = math.sqrt(a1_prime**2 + b1**2)
        C2_prime = math.sqrt(a2_prime**2 + b2**2)
        
        # Krok 6: Nowe odcienie (w stopniach)
        h1_prime = self._calculate_hue_angle(a1_prime, b1)
        h2_prime = self._calculate_hue_angle(a2_prime, b2)
        
        # Krok 7: R√≥≈ºnice
        delta_L_prime = L2 - L1
        delta_C_prime = C2_prime - C1_prime
        delta_h_prime = self._calculate_hue_difference(h1_prime, h2_prime, C1_prime, C2_prime)
        delta_H_prime = 2 * math.sqrt(C1_prime * C2_prime) * math.sin(math.radians(delta_h_prime / 2))
        
        # Krok 8: ≈örednie warto≈õci
        L_bar_prime = (L1 + L2) / 2.0
        C_bar_prime = (C1_prime + C2_prime) / 2.0
        h_bar_prime = self._calculate_mean_hue(h1_prime, h2_prime, C1_prime, C2_prime)
        
        # Krok 9: Funkcje wagowe
        SL = self._calculate_SL(L_bar_prime)
        SC = self._calculate_SC(C_bar_prime)
        T = self._calculate_T(h_bar_prime)
        SH = self._calculate_SH(C_bar_prime, T)
        
        # Krok 10: Korekcja obrotu
        delta_theta = 30 * math.exp(-((h_bar_prime - 275) / 25)**2)
        C_bar_prime_7 = C_bar_prime**7
        RC = 2 * math.sqrt(C_bar_prime_7 / (C_bar_prime_7 + 25**7))
        RT = -math.sin(math.radians(2 * delta_theta)) * RC
        
        # Krok 11: Sk≈Çadowe wa≈ºone
        L_component = delta_L_prime / (self.parameters.kL * SL)
        C_component = delta_C_prime / (self.parameters.kC * SC)
        H_component = delta_H_prime / (self.parameters.kH * SH)
        interaction_term = RT * C_component * H_component
        
        # Krok 12: Delta E CIEDE2000
        delta_e = math.sqrt(L_component**2 + C_component**2 + H_component**2 + interaction_term)
        
        if return_details:
            interpretation = self._interpret_delta_e(delta_e)
            
            intermediate_values = None
            if include_intermediate:
                intermediate_values = CIEDE2000IntermediateValues(
                    L1=L1, a1=a1, b1=b1, L2=L2, a2=a2, b2=b2,
                    L_bar=L_bar, C_bar_initial=C_bar_initial,
                    G=G, a1_prime=a1_prime, a2_prime=a2_prime,
                    C1_prime=C1_prime, C2_prime=C2_prime,
                    h1_prime=h1_prime, h2_prime=h2_prime,
                    delta_L_prime=delta_L_prime, delta_C_prime=delta_C_prime,
                    delta_h_prime=delta_h_prime, delta_H_prime=delta_H_prime,
                    L_bar_prime=L_bar_prime, C_bar_prime=C_bar_prime,
                    h_bar_prime=h_bar_prime, SL=SL, SC=SC, SH=SH, T=T,
                    delta_theta=delta_theta, RC=RC, RT=RT,
                    L_component=L_component, C_component=C_component,
                    H_component=H_component, interaction_term=interaction_term,
                    delta_E=delta_e
                )
            
            return CIEDE2000Result(
                delta_e=delta_e,
                color1_lab=color1,
                color2_lab=color2,
                parameters=self.parameters,
                intermediate_values=intermediate_values,
                interpretation=interpretation
            )
        
        return delta_e
    
    def _calculate_hue_angle(self, a_prime: float, b: float) -> float:
        """
        Oblicza kƒÖt odcienia w stopniach [0, 360)
        """
        if a_prime == 0 and b == 0:
            return 0.0
        
        hue_rad = math.atan2(b, a_prime)
        hue_deg = math.degrees(hue_rad)
        
        # Normalizacja do zakresu [0, 360)
        if hue_deg < 0:
            hue_deg += 360
        
        return hue_deg
    
    def _calculate_hue_difference(self, h1: float, h2: float, C1: float, C2: float) -> float:
        """
        Oblicza r√≥≈ºnicƒô odcienia z uwzglƒôdnieniem cykliczno≈õci
        """
        if C1 * C2 == 0:
            return 0.0
        
        delta_h = h2 - h1
        
        if abs(delta_h) <= 180:
            return delta_h
        elif delta_h > 180:
            return delta_h - 360
        else:
            return delta_h + 360
    
    def _calculate_mean_hue(self, h1: float, h2: float, C1: float, C2: float) -> float:
        """
        Oblicza ≈õredni odcie≈Ñ z uwzglƒôdnieniem cykliczno≈õci
        """
        if C1 * C2 == 0:
            return h1 + h2
        
        if abs(h1 - h2) <= 180:
            return (h1 + h2) / 2.0
        elif (h1 + h2) < 360:
            return (h1 + h2 + 360) / 2.0
        else:
            return (h1 + h2 - 360) / 2.0
    
    def _calculate_SL(self, L_bar_prime: float) -> float:
        """
        Oblicza funkcjƒô wagowƒÖ SL dla jasno≈õci
        """
        return 1 + (0.015 * (L_bar_prime - 50)**2) / math.sqrt(20 + (L_bar_prime - 50)**2)
    
    def _calculate_SC(self, C_bar_prime: float) -> float:
        """
        Oblicza funkcjƒô wagowƒÖ SC dla chromatyczno≈õci
        """
        return 1 + 0.045 * C_bar_prime
    
    def _calculate_T(self, h_bar_prime: float) -> float:
        """
        Oblicza funkcjƒô T dla odcienia
        """
        h_rad = math.radians(h_bar_prime)
        return (1 - 0.17 * math.cos(h_rad - math.radians(30)) +
                0.24 * math.cos(2 * h_rad) +
                0.32 * math.cos(3 * h_rad + math.radians(6)) -
                0.20 * math.cos(4 * h_rad - math.radians(63)))
    
    def _calculate_SH(self, C_bar_prime: float, T: float) -> float:
        """
        Oblicza funkcjƒô wagowƒÖ SH dla odcienia
        """
        return 1 + 0.015 * C_bar_prime * T
    
    def _validate_lab_color(self, color: Tuple[float, float, float], name: str):
        """Waliduje kolor LAB"""
        if not isinstance(color, (tuple, list)) or len(color) != 3:
            raise ValueError(f"{name} musi byƒá tuple/list z 3 elementami")
        
        L, a, b = color
        
        if not (0 <= L <= 100):
            raise ValueError(f"{name}: L* musi byƒá w zakresie [0, 100], otrzymano {L}")
        
        if not (-128 <= a <= 127):
            raise ValueError(f"{name}: a* musi byƒá w zakresie [-128, 127], otrzymano {a}")
        
        if not (-128 <= b <= 127):
            raise ValueError(f"{name}: b* musi byƒá w zakresie [-128, 127], otrzymano {b}")
        
        # Sprawdzenie NaN/inf
        if any(math.isnan(x) or math.isinf(x) for x in [L, a, b]):
            raise ValueError(f"{name}: Warto≈õci nie mogƒÖ byƒá NaN lub inf")
    
    def _interpret_delta_e(self, delta_e: float) -> str:
        """Interpretuje warto≈õƒá Delta E CIEDE2000"""
        if delta_e < 1:
            return "Niewidoczna r√≥≈ºnica"
        elif delta_e < 2:
            return "Ledwo widoczna r√≥≈ºnica"
        elif delta_e < 3:
            return "Widoczna przy por√≥wnaniu"
        elif delta_e < 6:
            return "Wyra≈∫nie widoczna r√≥≈ºnica"
        elif delta_e < 12:
            return "ZnaczƒÖca r√≥≈ºnica"
        else:
            return "Bardzo du≈ºa r√≥≈ºnica"
```

---

## Przyk≈Çady Podstawowe

### Demonstracja U≈ºycia

```python
def demonstrate_ciede2000_basic():
    """Demonstracja podstawowego u≈ºycia CIEDE2000"""
    print("=== Demonstracja CIEDE2000 ===")
    
    # Kolory testowe
    red = (53.24, 80.09, 67.20)      # Czerwony
    orange = (74.93, 23.93, 78.95)   # Pomara≈Ñczowy
    
    print(f"Kolor 1 (czerwony): LAB{red}")
    print(f"Kolor 2 (pomara≈Ñczowy): LAB{orange}")
    print("-" * 50)
    
    # Kalkulator CIEDE2000
    calculator = CIEDE2000Calculator()
    
    # Proste obliczenie
    delta_e = calculator.calculate(red, orange)
    print(f"CIEDE2000: {delta_e:.3f}")
    
    # Szczeg√≥≈Çowe informacje
    result = calculator.calculate(red, orange, return_details=True, include_intermediate=True)
    print(f"\n{result.detailed_breakdown()}")
    
    # Wk≈Çad sk≈Çadowych
    contributions = result.component_contributions()
    print(f"\n=== Wk≈Çad sk≈Çadowych ===")
    for component, value in contributions.items():
        print(f"{component}: {value:.1f}%")

# demonstrate_ciede2000_basic()
```

### Por√≥wnanie z Innymi Metodami

```python
def compare_all_delta_e_methods():
    """Por√≥wnuje wszystkie metody Delta E"""
    from delta_e_calculator import DeltaECalculator, DeltaEMethod
    
    # Kolory testowe
    test_colors = [
        ((50, 0, 0), (55, 0, 0), "Zmiana jasno≈õci"),
        ((50, 20, 0), (50, 25, 0), "Zmiana a*"),
        ((50, 0, 20), (50, 0, 25), "Zmiana b*"),
        ((50, 20, 20), (50, 25, 25), "Zmiana chromatyczno≈õci"),
        ((30, 0, -50), (30, 0, -45), "Niebieskie (ciemne)"),
        ((70, 0, -50), (70, 0, -45), "Niebieskie (jasne)"),
        ((50, 60, 60), (55, 65, 65), "Wysoka chromatyczno≈õƒá"),
        ((50, 5, 5), (55, 10, 10), "Niska chromatyczno≈õƒá")
    ]
    
    print("=== Por√≥wnanie Wszystkich Metod Delta E ===")
    
    # Kalkulatory
    cie76_calc = DeltaECalculator(DeltaEMethod.CIE76)
    cie94_graphic_calc = CIE94Calculator(CIE94Application.GRAPHIC_ARTS)
    cie94_textile_calc = CIE94Calculator(CIE94Application.TEXTILES)
    ciede2000_calc = CIEDE2000Calculator()
    
    for color1, color2, description in test_colors:
        print(f"\n--- {description} ---")
        print(f"Kolory: {color1} ‚Üí {color2}")
        
        # Obliczenia
        cie76_result = cie76_calc.calculate(color1, color2)
        cie94_graphic = cie94_graphic_calc.calculate(color1, color2)
        cie94_textile = cie94_textile_calc.calculate(color1, color2)
        ciede2000_result = ciede2000_calc.calculate(color1, color2)
        
        print(f"CIE76:           {cie76_result:.3f}")
        print(f"CIE94 (grafika): {cie94_graphic:.3f}")
        print(f"CIE94 (tekstyl): {cie94_textile:.3f}")
        print(f"CIEDE2000:       {ciede2000_result:.3f}")
        
        # Analiza r√≥≈ºnic
        methods = {
            'CIE76': cie76_result,
            'CIE94_G': cie94_graphic,
            'CIE94_T': cie94_textile,
            'CIEDE2000': ciede2000_result
        }
        
        min_method = min(methods, key=methods.get)
        max_method = max(methods, key=methods.get)
        range_value = methods[max_method] - methods[min_method]
        
        print(f"Zakres: {range_value:.3f} ({min_method} ‚Üí {max_method})")

# compare_all_delta_e_methods()
```

---

## Analiza Funkcji Korekcyjnych

### Wizualizacja Funkcji Wagowych

```python
import matplotlib.pyplot as plt

def visualize_ciede2000_weighting_functions():
    """Wizualizuje funkcje wagowe CIEDE2000"""
    calculator = CIEDE2000Calculator()
    
    fig, axes = plt.subplots(2, 2, figsize=(15, 12))
    
    # 1. Funkcja SL (jasno≈õƒá)
    L_values = np.linspace(0, 100, 1000)
    SL_values = [calculator._calculate_SL(L) for L in L_values]
    
    axes[0, 0].plot(L_values, SL_values, 'b-', linewidth=2)
    axes[0, 0].set_xlabel('L* (Jasno≈õƒá)')
    axes[0, 0].set_ylabel('SL (Waga jasno≈õci)')
    axes[0, 0].set_title('Funkcja Wagowa SL')
    axes[0, 0].grid(True, alpha=0.3)
    axes[0, 0].axhline(y=1, color='r', linestyle='--', alpha=0.5, label='SL = 1')
    axes[0, 0].legend()
    
    # 2. Funkcja SC (chromatyczno≈õƒá)
    C_values = np.linspace(0, 100, 1000)
    SC_values = [calculator._calculate_SC(C) for C in C_values]
    
    axes[0, 1].plot(C_values, SC_values, 'g-', linewidth=2)
    axes[0, 1].set_xlabel('C* (Chromatyczno≈õƒá)')
    axes[0, 1].set_ylabel('SC (Waga chromatyczno≈õci)')
    axes[0, 1].set_title('Funkcja Wagowa SC')
    axes[0, 1].grid(True, alpha=0.3)
    
    # 3. Funkcja T (odcie≈Ñ)
    h_values = np.linspace(0, 360, 1000)
    T_values = [calculator._calculate_T(h) for h in h_values]
    
    axes[1, 0].plot(h_values, T_values, 'r-', linewidth=2)
    axes[1, 0].set_xlabel('h* (Odcie≈Ñ, stopnie)')
    axes[1, 0].set_ylabel('T (Funkcja odcienia)')
    axes[1, 0].set_title('Funkcja T dla Odcienia')
    axes[1, 0].grid(True, alpha=0.3)
    axes[1, 0].set_xlim(0, 360)
    
    # 4. Funkcja RT (korekcja obrotu)
    h_values_rt = np.linspace(200, 350, 1000)
    C_test = 50  # Sta≈Ça chromatyczno≈õƒá dla testu
    RT_values = []
    
    for h in h_values_rt:
        delta_theta = 30 * math.exp(-((h - 275) / 25)**2)
        C_7 = C_test**7
        RC = 2 * math.sqrt(C_7 / (C_7 + 25**7))
        RT = -math.sin(math.radians(2 * delta_theta)) * RC
        RT_values.append(RT)
    
    axes[1, 1].plot(h_values_rt, RT_values, 'm-', linewidth=2)
    axes[1, 1].set_xlabel('h* (Odcie≈Ñ, stopnie)')
    axes[1, 1].set_ylabel('RT (Korekcja obrotu)')
    axes[1, 1].set_title(f'Funkcja Korekcji Obrotu RT (C*={C_test})')
    axes[1, 1].grid(True, alpha=0.3)
    axes[1, 1].axhline(y=0, color='k', linestyle='-', alpha=0.3)
    
    plt.tight_layout()
    plt.show()

# visualize_ciede2000_weighting_functions()
```

### Analiza Korekcji G

```python
def analyze_g_correction():
    """Analizuje wp≈Çyw korekcji G na warto≈õci a*"""
    print("=== Analiza Korekcji G ===")
    
    # Test r√≥≈ºnych poziom√≥w chromatyczno≈õci
    test_cases = [
        (0, 0, "Szary (brak chromatyczno≈õci)"),
        (10, 10, "Niska chromatyczno≈õƒá"),
        (30, 30, "≈örednia chromatyczno≈õƒá"),
        (60, 60, "Wysoka chromatyczno≈õƒá"),
        (100, 100, "Bardzo wysoka chromatyczno≈õƒá")
    ]
    
    calculator = CIEDE2000Calculator()
    
    for a, b, description in test_cases:
        # Obliczenie chromatyczno≈õci
        C = math.sqrt(a**2 + b**2)
        
        # Obliczenie G dla pary kolor√≥w o tej samej chromatyczno≈õci
        C_bar = C  # ≈örednia = C dla identycznych kolor√≥w
        C_bar_7 = C_bar**7
        G = 0.5 * (1 - math.sqrt(C_bar_7 / (C_bar_7 + 25**7)))
        
        # Skorygowane a'
        a_prime = (1 + G) * a
        
        print(f"\n{description}:")
        print(f"  Oryginalne: a*={a}, b*={b}, C*={C:.2f}")
        print(f"  Korekcja G: {G:.4f}")
        print(f"  Skorygowane: a'={a_prime:.2f} (zmiana: {((a_prime-a)/a*100) if a != 0 else 0:.1f}%)")
        
        # Wp≈Çyw na chromatyczno≈õƒá
        C_prime = math.sqrt(a_prime**2 + b**2)
        print(f"  Nowa chromatyczno≈õƒá C': {C_prime:.2f} (zmiana: {((C_prime-C)/C*100) if C != 0 else 0:.1f}%)")

# analyze_g_correction()
```

---

## Podsumowanie Czƒô≈õci 5a

W tej czƒô≈õci om√≥wili≈õmy:

1. **Teoretyczne podstawy CIEDE2000** - najbardziej zaawansowanej formu≈Çy Delta E
2. **KompleksnƒÖ implementacjƒô** - wszystkie kroki algorytmu
3. **Struktury danych** - szczeg√≥≈Çowe przechowywanie wynik√≥w
4. **Funkcje korekcyjne** - G, SL, SC, SH, T, RT
5. **Przyk≈Çady podstawowe** - demonstracja u≈ºycia

### Kluczowe Cechy CIEDE2000

‚úÖ **Najwy≈ºsza dok≈Çadno≈õƒá** - najlepsza korelacja z percepcjƒÖ  
‚úÖ **Kompleksowe korekcje** - wszystkie aspekty percepcji  
‚úÖ **Korekcja obrotu** - specjalne traktowanie niebieskich  
‚úÖ **Funkcje wagowe** - dostosowane do ludzkiego oka  
‚ùå **Z≈Ço≈ºono≈õƒá** - najbardziej skomplikowana implementacja  
‚ùå **Wydajno≈õƒá** - najwolniejsza w obliczeniach  

### Co dalej?

**Czƒô≈õƒá 5b** bƒôdzie zawieraƒá:
- Optymalizacje wydajno≈õci (NumPy, Numba)
- Batch processing dla du≈ºych zbior√≥w danych
- Zaawansowane analizy i por√≥wnania
- Praktyczne zastosowania i case studies
- Benchmarki wydajno≈õci wszystkich metod

---

**Autor**: GattoNero AI Assistant  
**Data utworzenia**: 2024-01-20  
**Ostatnia aktualizacja**: 2024-01-20  
**Wersja**: 1.0  
**Status**: ‚úÖ Czƒô≈õƒá 5a - CIEDE2000 implementacja podstawowa